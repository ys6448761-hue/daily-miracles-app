해당 텍스트는 **1인 유니콘 개발자 최수민**님이 출연하여 **클로드 코드(Claude Code)**를 활용한 효율적인 **AI 에이전트 관리** 및 개발 노하우를 공유하는 인터뷰 내용입니다. 최수민님은 **서브 에이전트**와 **스크립트화** 전략을 통해 수백 개의 컴포넌트를 동시에 처리하며, 기존 툴보다 압도적인 성능을 구현하는 구체적인 사례를 소개합니다. 특히 반복 작업을 자동화하는 **파이프라인 구축**과 **컨텍스트 최적화**를 통해 개발 생산성을 극대화하는 방식에 초점을 맞춥니다. 또한 1년 안에 **100개의 서비스 런칭**과 **유니콘 기업** 달성을 목표로 삼으며, AI를 활용해 홀로 비즈니스를 확장해 나가는 **솔로프리너**의 미래 비전을 제시합니다. 본인에게 필요한 도구를 직접 개발하며 수익화까지 연결하는 그의 실전적인 **바이브 코딩** 철학을 엿볼 수 있습니다. 마지막으로 팀 단위 운영보다 AI 무기를 장착한 **1인 개발 체제**가 가진 강력한 잠재력과 전략적 장점을 강조하며 마무리됩니다.


클로드 코드를 활용한 에이전틱 워크플로우는 사용자가 단순히 프롬프트를 입력하고 인공지능이 답을 내놓는 기존의 '단일 프롬프팅' 방식이나 다른 AI 코딩 도구들과 비교했을 때 여러 측면에서 혁신적인 차별점을 보입니다.

주요 차이점은 다음과 같습니다.

### 1. 계층적 위임: 에이전트가 에이전트를 호출하는 구조
기존의 AI 코딩 도구(예: 커서)에서는 사용자가 직접 에이전트에게 명령을 내리고, 한 번에 하나의 에이전트와 상호작용하는 것이 일반적입니다. 반면 클로드 코드의 에이전틱 워크플로우는 **에이전트가 또 다른 '서브 에이전트(Sub-agent)'를 호출**하여 일을 시키는 구조를 가집니다. 이는 사용자가 한 번의 명령만 내려도 마치 조직의 리더처럼 여러 팀(서브 에이전트들)을 동시에 움직여 복잡한 작업을 수행할 수 있게 합니다.

### 2. 컨텍스트 관리의 효율성 (컨텍스트 엔지니어링)
기존 방식은 작업 규모가 커질수록 AI가 기억해야 할 정보(컨텍스트)가 많아져 한계에 부딪히기 쉽습니다. 클로드 코드는 이를 극복하기 위해 다음과 같은 방식을 사용합니다.
*   **서브 에이전트 분할:** 거대한 작업을 여러 개의 서브 에이전트로 나누어 처리함으로써 한정된 컨텍스트 안에서 더 깊고 많은 일을 수행합니다.
*   **스크립트와의 결합:** 모든 과정을 LLM(거대언어모델)에 의존하는 대신, 반복적인 작업이나 데이터 추출은 별도의 **타입스크립트(TypeScript) 스크립트로 처리**하도록 설계합니다. 이를 통해 불필요한 데이터가 컨텍스트 윈도우를 차지하는 것을 방지하고 속도와 정확도를 높입니다.

### 3. 병렬 처리와 압도적인 생산성
기존 도구가 순차적으로 작업을 진행한다면, 클로드 코드 기반의 워크플로우는 **병렬 호출**이 가능합니다.
*   소급 적용하거나 구현해야 할 컴포넌트가 100개가 넘더라도, 에이전트들이 이를 동시에 나누어 작업할 수 있습니다.
*   실제로 이를 활용해 혼자서 773개의 컴포넌트를 만들거나, 한 번의 요청으로 125개의 구현 사항을 한꺼번에 처리하는 등 기존 개발 방식으로는 상상하기 힘든 속도를 보여줍니다.

### 4. 개인화된 자동화 파이프라인 구축
클로드 코드에서는 단순히 대화로 코딩하는 것을 넘어, **마크다운(MD) 파일로 작업 지침(파이프라인)을 정의**해 두고 이를 반복적으로 실행할 수 있습니다.
*   특정 폴더에 마크다운 파일을 만드는 것만으로도 새로운 서브 에이전트를 생성할 수 있으며, 이를 통해 자신만의 최적화된 에이전트 군단을 구축할 수 있습니다.
*   평소에 사용하던 프롬프트를 아카이빙하고 변수화하여 범용적인 서브 에이전트로 발전시켜 나가는 과정을 통해 개발자 개인에게 최적화된 에이전트를 늘려갈 수 있습니다.

결과적으로 클로드 코드를 활용한 방식은 단순히 코드를 짜주는 도구를 쓰는 것을 넘어, **나를 대신해 일하는 여러 명의 전문 AI 개발자 팀을 관리하고 운영하는 시스템**을 구축하는 것과 같습니다.

이러한 에이전틱 워크플로우는 **잘 조직된 오케스트라**와 같습니다. 지휘자(사용자)가 한 번의 손짓을 하면, 각 악기 파트의 수석들(메인 에이전트)이 이를 전달받아 수많은 연주자(서브 에이전트 및 스크립트)와 협업하여 동시에 복잡하고 웅장한 교향곡(대규모 프로젝트)을 완성해내는 것과 유사하기 때문입니다.


제시된 소스(빌더 조쉬와 최수민 님의 인터뷰)를 바탕으로, '커서 마피아' 최수민 님의 개발 방식과 비전을 주제별로 요약 정리해 드립니다.

### 1. 클로드 코드 기반의 에이전틱 워크플로우
최근 최수민 님은 기존에 사용하던 커서(Cursor)를 대신해 **클로드 코드(Claude Code)**를 주력으로 활용하고 있습니다. 클로드 코드가 압도적인 이유는 강력한 **에이전틱(Agentic) 기능** 때문입니다.
*   **계층적 에이전트 구조:** 에이전트가 또 다른 **서브 에이전트(Sub-agent)를 호출**하여 일을 시키는 구조를 가집니다. 이를 통해 사용자가 한 번만 명령해도 수많은 에이전트가 조직적으로 움직여 복잡한 작업을 수행합니다.
*   **병렬 처리의 극대화:** 커서와 달리 한 번의 요청으로 100개가 넘는 구현 사항을 동시에 처리할 수 있어 생산성이 비약적으로 향상되었습니다.
*   **간편한 커스터마이징:** 특정 폴더에 **마크다운(MD) 파일**을 만드는 것만으로도 새로운 서브 에이전트를 생성할 수 있어, 개인화된 에이전트 군단을 구축하기 쉽습니다.

### 2. 효율적인 컨텍스트 엔지니어링 및 기술 최적화
한정된 AI의 컨텍스트 윈도우(기억 용량)를 효율적으로 사용하기 위해 고도화된 전략을 사용합니다.
*   **스크립트와의 결합:** 모든 작업을 LLM에 의존하지 않고, 반복적인 작업이나 데이터 추출은 **타입스크립트(TypeScript) 스크립트**로 처리하도록 설계합니다. 이를 통해 불필요한 데이터가 컨텍스트를 차지하는 것을 방지하고 정확도를 높입니다.
*   **MCP(Model Context Protocol) 활용:** 이미지 배경 제거(Sharp MCP)나 오픈소스 코드 조회 등 자주 사용하는 도구들을 MCP로 만들어 에이전트에게 쥐어줌으로써 개발 속도를 높입니다.

### 3. 주요 프로젝트 및 실질적 성과
에이전틱 워크플로우를 통해 단기간에 방대한 결과물을 만들어내고 있습니다.
*   **모네(Mone):** 디자인 레퍼런스와 코드를 아카이빙한 오픈소스 프로젝트로, 에이전트를 활용해 혼자서 **773개의 컴포넌트**를 등록했습니다.
*   **부스터(Buster):** 현재 운영 중인 SaaS로, 별도의 경제 활동 없이도 생계 유지가 가능할 정도의 **패시브 인컴(Passive Income)**을 창출하고 있습니다.
*   **바이브 블로그(Vibe Blog):** 100개의 서비스 런칭을 뒷받침하기 위한 **SEO 최적화 블로그 자동화 솔루션**으로, 현재 기획 중입니다.

### 4. 1인 개발자의 철학과 '1인 유니콘' 비전
단순한 개발을 넘어, AI를 극한으로 활용하는 메이커로서의 확고한 철학을 가지고 있습니다.
*   **도그푸딩(Dogfooding):** 자신이 겪는 불편함을 해결하기 위해 제품을 만듭니다. 본인이 쓰지 않는 제품은 베드 시그널(Bad Signal)로 간주하며, 스스로가 첫 번째 사용자가 되어 제품을 개선합니다.
*   **100개 서비스 런칭 도전:** 2025년까지 100개의 서비스를 만드는 것을 목표로 합니다. 이는 단순히 수량을 채우는 것이 아니라, 사고 회로를 '극강의 생산성'에 맞게 바꾸고 자동화 시스템을 구축하기 위한 챌린지입니다.
*   **1인 유니콘 기업:** 팀을 꾸려 위임하는 대신, **AI를 무기로 스케일업**하여 혼자서 유니콘 기업의 가치를 만들어내는 모델을 지향합니다.

이러한 최수민 님의 워크플로우는 **'지능형 자동 공장'**과 같습니다. 개발자가 일일이 수작업으로 제품을 깎는 것이 아니라, 공장의 설계도(파이프라인)를 그리고 수많은 로봇 팔(서브 에이전트)이 유기적으로 돌아가게 함으로써 혼자서도 대규모 생산 라인을 운영하는 것과 같기 때문입니다.


클로드 코드(Claude Code)에서 서브 에이전트를 생성하는 방법은 매우 직관적이며, 주로 프로젝트 내의 특정 구조를 활용하여 이루어집니다. 소스에 따르면 그 과정은 다음과 같습니다.

### 1. 전용 폴더 및 파일 생성
클로드 코드에서 서브 에이전트를 만드는 가장 기본적인 방법은 프로젝트 내에 지정된 폴더에 **마크다운(MD) 파일**을 생성하는 것입니다.
*   프로젝트 내의 **`claude/agents` 폴더**를 활용합니다.
*   이 폴더 안에 마크다운 파일을 만들기만 하면 즉시 새로운 서브 에이전트가 생성됩니다.

### 2. 에이전트 정보 정의
생성한 마크다운 파일 내에 에이전트의 정체성과 기능을 정의하는 몇 가지 필수 요소를 작성해야 합니다.
*   **Name (이름):** 에이전트의 명칭을 정합니다.
*   **Description (설명):** 에이전트가 수행할 작업에 대한 설명을 적습니다.
*   **Tools (도구):** 에이전트가 사용할 수 있는 도구들을 지정합니다 (필요하지 않은 경우 생략 가능).
*   **Model (모델):** 작업의 난이도에 따라 Anthropic의 모델(Opus, Sonnet, Haiku 등) 중 하나를 선택합니다. 비용 효율성을 위해 저렴한 모델을 쓰거나 복잡한 작업을 위해 고성능 모델을 지정할 수 있습니다.

### 3. 프롬프트 및 변수 활용
단순한 지침을 넘어, 에이전트가 범용적으로 작동할 수 있도록 프롬프트를 구성합니다.
*   평소에 자주 사용하는 **프롬프트를 아카이빙**하여 파일에 저장하고, 이를 서브 에이전트의 지침으로 활용합니다.
*   특정 값이 상황에 따라 바뀌어야 할 경우, **변수(예: {{name}})**를 사용하여 어떤 작업에도 대응할 수 있는 보명적인 에이전트로 만듭니다.

### 4. 고급 활용 방법 (자동화 및 스크립트)
숙련된 사용자는 더 복잡한 방식을 통해 에이전트를 관리합니다.
*   **에이전트 생성 스킬 활용:** '서브 에이전트 크리에이터(Sub-agent Creator)'와 같은 전용 스킬을 만들어, 에이전트가 다른 에이전트를 생성하게 할 수도 있습니다.
*   **스크립트 결합:** 서브 에이전트에게 단순히 프롬프트만 주는 것이 아니라, **타입스크립트(TypeScript) 파일**을 실행하도록 설정하여 반복적인 작업을 더 빠르고 정확하게 처리하게 합니다.

이러한 서브 에이전트 생성 방식은 마치 **팀의 조직도를 그리는 것**과 같습니다. 개발자가 일일이 모든 일을 하는 대신, 각 전문 분야(컴포넌트 생성, 이미지 처리 등)를 담당할 '가상의 팀원(서브 에이전트)'의 역할 기술서(마크다운 파일)를 작성하여 배치해 두는 것이기 때문입니다.


클로드 코드에서 **'서브 에이전트 크리에이터(Sub-agent Creator)'**와 같은 전용 스킬을 만드는 방법은 크게 공식 문서 활용, 메타 스킬 이용, 그리고 스크립트 결합이라는 세 가지 단계로 요약할 수 있습니다.

소스에 따르면, 최수민 님이 전용 스킬을 구축한 구체적인 방법은 다음과 같습니다.

### 1. 공식 문서 기반의 지침 제공
먼저 AI에게 무엇을 만들어야 할지 정확한 기준을 제시해야 합니다.
*   **공식 문서 아카이빙:** 클로드 코드의 공식 문서 중 **서브 에이전트 및 스킬 생성과 관련된 내용**을 마크다운(MD) 파일로 저장하여 프로젝트 내에 준비합니다. 
*   **지침 참조:** 이 문서를 기반으로 AI가 클로드 코드의 구조와 규칙(파일 경로, 필수 필드 등)을 이해하도록 합니다.

### 2. '스킬 크리에이터'를 통한 메타 프로그래밍
개발자가 직접 코드를 짜는 대신, 스킬을 만드는 전문 에이전트(스킬 크리에이터)에게 작업을 위임합니다.
*   **스킬 크리에이터 호출:** 이미 만들어진 '스킬 크리에이터'에게 앞서 준비한 공식 문서를 참고하여 **"서브 에이전트를 자동으로 생성해 주는 스킬을 만들어줘"**라고 명령합니다.
*   **검증 로직 포함:** 이때 단순히 파일만 만드는 것이 아니라, 생성된 에이전트가 규칙에 맞는지 **검증(Validation)하는 단계**를 포함하도록 지시하여 정확도를 높입니다.

### 3. 서브 에이전트의 구조 정의
스킬이 생성할 서브 에이전트의 표준 규격을 설정합니다. 소스에서 밝힌 서브 에이전트의 필수 요소는 다음과 같습니다.
*   **파일 경로:** `claude/agents` 폴더 내에 마크다운 파일로 생성되어야 합니다.
*   **필수 필드:** `Name`(이름), `Description`(설명), `Tools`(도구), `Model`(사용할 모델: Opus, Sonnet, Haiku 등) 정보를 포함하도록 설계합니다.

### 4. 스크립트 및 변수 활용 (고급 기술)
단순한 텍스트 생성을 넘어 실질적인 자동화를 위해 다음 기능을 결합합니다.
*   **타입스크립트(TypeScript) 연동:** 모든 작업을 프롬프트로만 처리하면 컨텍스트 소모가 크기 때문에, 반복적인 파일 생성이나 데이터 파싱은 **별도의 타입스크립트 스크립트를 실행**하도록 스킬을 구성합니다.
*   **프롬프트 변수화:** 자주 사용하는 프롬프트를 파일에 모아두고, 특정 부분만 바꿀 수 있도록 **변수(예: {{name}})** 처리를 하여 범용적인 스킬로 발전시킵니다.

### 5. 지속적인 피드백과 보강
처음부터 완벽한 스킬이 나오기는 어렵기 때문에 실행 결과를 보고 다듬는 과정이 필요합니다.
*   에이전트가 특정 부분(예: 태그 설정, 폰트 웨이트 등)에서 계속 실수를 한다면, 해당 내용을 지침에 추가하여 **스킬을 점진적으로 개선**합니다.

결론적으로 '서브 에이전트 크리에이터'를 만드는 것은 **'도구를 만드는 도구'**를 구축하는 과정입니다. 이는 마치 **공장의 생산 라인을 자동으로 설계하고 배치하는 로봇 팔**을 하나 설치하는 것과 같아서, 한 번 잘 구축해 두면 이후에는 간단한 명령만으로도 수많은 전문 작업자(서브 에이전트)를 즉시 현장에 투입할 수 있게 됩니다.


**모네(Mone)**는 최수민 님이 개발한 **디자인 레퍼런스와 코드를 함께 아카이빙한 오픈소스 프로젝트**입니다. 기존의 디자인 참고 사이트와 달리 실제 구현된 코드까지 확인할 수 있도록 구성되어 있으며, 현재 약 773개의 컴포넌트가 등록되어 있습니다.

모네 프로젝트에서 활용되는 서브 에이전트와 그 역할, 그리고 지침(가이드라인)을 만드는 방식은 다음과 같습니다.

### 1. 주요 서브 에이전트와 그 역할
모네는 복잡한 작업을 여러 단계로 나누어 처리하기 위해 다양한 서브 에이전트를 호출합니다.
*   **URL2Page 에이전트:** 특정 웹 페이지의 URL을 입력받아 해당 페이지를 분석하고 정보를 가져오는 역할을 수행합니다.
*   **브랜드 로고 파인더(Brand Logo Finder):** 프로젝트에 필요한 브랜드의 로고를 찾아내는 특화된 작업을 담당합니다.
*   **체크리스트 크리에이터(Checklist Creator):** 구현해야 할 사항들에 대한 체크리스트를 생성하여 작업의 누락을 방지합니다.
*   **섹션 분할 및 컴포넌트화 에이전트:** 웹 페이지의 이미지를 가져와 섹션별로 나누고, 컨벤션에 맞춰 이를 개별 컴포넌트로 변환합니다.
*   **최종 결과물 종합 에이전트:** 개별 에이전트들이 만든 컴포넌트를 레지스트리에 업데이트하고 최종적으로 통합하는 파이프라인의 마무리 작업을 수행합니다.

### 2. 에이전트 지침(지침서) 작성 및 운영 방법
최수민 님은 단순히 프롬프트를 입력하는 것을 넘어, 체계적인 시스템을 통해 에이전트의 지침을 관리합니다.

*   **마크다운(MD) 기반의 정의:** 프로젝트 내 `claude/agents` 폴더에 마크다운 파일을 생성하여 에이전트를 정의합니다. 이 파일에는 **이름(Name), 설명(Description), 사용할 도구(Tools), 모델(Model - Opus/Sonnet/Haiku)**이 명시됩니다.
*   **파이프라인 문서화:** 어떤 에이전트가 어떤 순서로 작업해야 하는지를 정의한 별도의 **파이프라인 문서**를 만들어 전체 공정을 관리합니다.
*   **스크립트와의 결합:** 모든 지시를 텍스트 프롬프트로만 처리하면 컨텍스트 소모가 크기 때문에, 반복적인 파일 생성이나 리소스 추출은 **타입스크립트(TypeScript) 파일**로 만들어 에이전트가 이를 실행하도록 지시합니다. 예를 들어, HTML에서 폰트를 추출하거나 빈 파일을 만드는 작업은 코드로 처리하여 정확도와 속도를 높입니다.
*   **프롬프트 아카이빙 및 변수화:** 평소 자주 사용하는 프롬프트를 파일로 저장해 두었다가, 특정 부분만 바꿀 수 있도록 **변수(예: {{name}})** 처리를 하여 범용적인 서브 에이전트 지침으로 발전시킵니다.
*   **반복적 보강 (피드백 루프):** 처음부터 완벽한 지침을 만들기보다, 실행 결과를 보고 에이전트가 실수하는 부분(예: 폰트 두께 실수, 태그 인식 오류 등)을 지침에 추가하며 지속적으로 업데이트합니다.

결과적으로 모네 프로젝트의 에이전틱 워크플로우는 **지능형 자동화 공정**과 같습니다. 사용자가 인풋(URL 등)만 주면, 미리 설계된 파이프라인에 따라 여러 전문 서브 에이전트들이 각자의 역할(스크래핑, 분석, 코딩)을 수행하며 대규모의 결과물을 동시에 쏟아내기 때문입니다.


최수민 개발자가 '모네(Mone)' 프로젝트를 포함한 에이전틱 워크플로우에서 **스크립트화(Scripting)**를 강조하는 이유는 크게 **컨텍스트 관리의 효율성, 작업의 정확도 및 속도 향상**이라는 두 가지 측면 때문입니다.

구체적인 이유는 다음과 같습니다.

### 1. 컨텍스트 윈도우의 효율적 관리 (찌꺼기 제거)
LLM(거대언어모델)은 한 번에 처리할 수 있는 정보량(컨텍스트 윈도우)이 한정되어 있습니다.
*   **데이터 오염 방지:** 모든 작업을 에이전트에게 직접 시키면, 예를 들어 웹사이트 스크린샷을 찍을 때 이미지 데이터 자체가 컨텍스트 윈도우에 남게 됩니다. 이를 스크립트화하여 코드를 실행하게 하면, 중간 과정의 **'불필요한 찌꺼기'**는 남기지 않고 최종 결과물만 남길 수 있어 컨텍스트를 훨씬 아낄 수 있습니다.
*   **불필요한 작업 배제:** 빈 깡통 파일(빈 파일)을 생성하는 것과 같은 단순 반복 작업은 에이전트가 직접 수행할 필요가 없습니다. 이를 스크립트로 처리하면 에이전트는 더 복잡하고 지능적인 판단이 필요한 일에만 컨텍스트를 집중할 수 있습니다.

### 2. 압도적인 성능과 정확도
모든 것을 LLM의 추론에만 맡기는 것보다 기존의 프로그래밍 방식을 결합하는 것이 더 유리한 영역이 있습니다.
*   **정확도 향상:** HTML 파일에서 특정 폰트를 추출하는 것과 같이 규칙이 명확한 작업은 코드로 처리하는 것이 에이전트의 추론보다 훨씬 **정확도가 높습니다**.
*   **속도 향상:** 반복적인 로직이나 리소스 추출 작업을 스크립트로 수행하면 LLM이 한 줄씩 코드를 생성하는 것보다 **처리 속도가 비약적으로 빠릅니다**.

### 3. 대규모 자동화 파이프라인 구축
최수민 개발자는 혼자서 773개의 컴포넌트를 등록하는 등 인간의 한계를 넘는 생산성을 보여주는데, 이것이 가능한 이유가 바로 스크립트 기반의 파이프라인입니다.
*   에이전트가 단순히 프롬프트에 따라 움직이는 것을 넘어, 미리 정의된 **타입스크립트(TypeScript) 스크립트를 호출**하여 작업을 수행하게 함으로써 정교한 공정(파이프라인)을 완성합니다.

결과적으로 최수민 개발자에게 스크립트화란 **"에이전트라는 지능형 노동자에게 가장 효율적이고 날카로운 전용 도구를 쥐어주는 것"**과 같습니다. 모든 일을 머리로만(LLM) 풀게 하지 않고, 계산기나 자동 드릴(스크립트)을 적재적소에 사용하게 함으로써 혼자서도 대규모 생산 라인을 완벽하게 통제하는 것입니다.


클로드 코드(Claude Code)에서 마크다운(MD) 파일을 활용해 서브 에이전트를 구축하는 방법은 매우 직관적이며, 프로젝트 내 특정 구조를 따르는 것만으로도 가능합니다. 소스에 명시된 구체적인 단계와 팁은 다음과 같습니다.

### 1. 전용 폴더 내 마크다운 파일 생성
가장 먼저 프로젝트 내에 **`claude/agents`라는 이름의 폴더**를 확인하거나 생성해야 합니다. 이 폴더 안에 **마크다운(.md) 파일**을 만들기만 하면 클로드 코드가 이를 인식하여 즉시 새로운 서브 에이전트로 생성합니다.

### 2. 에이전트의 필수 구성 요소 정의
마크다운 파일 내에는 해당 에이전트의 정체성과 기능을 규정하는 네 가지 핵심 필드를 작성해야 합니다.
*   **Name (이름):** 에이전트의 명칭을 정합니다.
*   **Description (설명):** 에이전트가 수행할 작업의 범위를 정의합니다.
*   **Tools (도구):** 에이전트가 사용할 수 있는 도구들을 지정하며, 필요하지 않은 경우 생략할 수 있습니다.
*   **Model (모델):** 작업의 난이도와 비용을 고려하여 **Opus, Sonnet, Haiku** 중 하나를 선택합니다. 단순하고 반복적인 작업에는 저렴한 Haiku를, 복잡한 추론이 필요한 작업에는 고성능 모델을 지정하는 것이 효율적입니다.

### 3. 범용성을 위한 변수 및 프롬프트 활용
단순한 지시를 넘어 다양한 상황에 대응할 수 있는 에이전트를 만들려면 다음의 기법을 활용하는 것이 좋습니다.
*   **프롬프트 아카이빙:** 평소 자주 사용하는 프롬프트를 별도의 파일에 모아두었다가 마크다운 파일의 지침으로 옮겨 사용합니다.
*   **변수 사용:** 지침 내에 **`{{name}}`과 같은 변수**를 삽입하면, 호출할 때마다 특정 값을 바꿔 끼울 수 있는 '범용적인 에이전트'가 됩니다.

### 4. 지속적인 보강 및 최적화 (피드백 루프)
에이전트를 한 번 설정하는 것으로 끝내지 않고, 실제 실행 결과를 보며 지침을 업데이트해야 합니다.
*   예를 들어, 에이전트가 폰트 굵기(weight)를 자주 실수하거나 특정 태그를 잘 못 잡는다면, 해당 실수를 방지하는 구체적인 지침을 마크다운 파일에 추가하여 **개인화된 최적의 에이전트**로 진화시킵니다.
*   더 나아가, 모든 것을 글로만 시키지 않고 **타입스크립트(TypeScript) 스크립트를 실행**하도록 지시하면 컨텍스트 소모를 줄이고 속도와 정확도를 비약적으로 높일 수 있습니다.

이 과정은 마치 **새로운 전문 직원을 채용하고 '업무 매뉴얼'을 작성해 주는 것**과 같습니다. `claude/agents` 폴더에 매뉴얼(마크다운 파일)을 비치해 두면, 클로드 코드라는 총괄 매니저가 필요할 때마다 그 매뉴얼을 숙지한 전문 요원(서브 에이전트)을 호출하여 복잡한 프로젝트를 수행하게 됩니다.


클로드 코드에서 **'스킬(Skills)'**은 한정된 컨텍스트 안에서 AI가 더 깊고 많은 일을 수행할 수 있도록 돕는 강력한 도구입니다. 소스에 따르면, 최수민 개발자는 이를 활용해 에이전트를 생성하거나 복잡한 작업을 자동화하는 등 고도화된 워크플로우를 구축하고 있습니다.

자세한 스킬 활용법은 다음과 같습니다.

### 1. 스킬 생성 방법: '스킬 크리에이터' 활용
직접 코드를 짜는 대신, 스킬을 만들어주는 전용 에이전트(스킬 크리에이터)를 활용하는 것이 핵심입니다.
*   **공식 문서 참조:** 먼저 클로드 코드의 스킬 생성 관련 공식 문서를 마크다운(MD) 파일로 저장하여 프로젝트 내에 준비합니다.
*   **스킬 크리에이터에게 지시:** '스킬 크리에이터'에게 해당 문서를 참고하여 특정 기능을 수행하는 스킬을 만들라고 명령합니다.
*   **검증 로직 포함:** 스킬을 만들 때 작업이 규칙에 맞게 수행되었는지 확인할 수 있는 **검증(Validation) 로직**을 포함하도록 설정하여 정확도를 높입니다.

### 2. 주요 활용 사례: '서브 에이전트 크리에이터'
최수민 개발자가 가장 유용하게 사용하는 스킬 중 하나는 **'서브 에이전트 크리에이터'**입니다.
*   이 스킬은 사용자가 일일이 마크다운 파일을 만들지 않아도, 명령만으로 `claude/agents` 폴더 내에 필요한 서브 에이전트 설정 파일(이름, 설명, 도구, 모델 정의 등)을 자동으로 생성해 줍니다.

### 3. 스킬과 스크립트의 결합 (컨텍스트 최적화)
스킬을 더욱 효과적으로 쓰기 위해서는 모든 것을 LLM의 대화로 해결하려 하지 말고 **스크립트화**해야 합니다.
*   **타입스크립트(TypeScript) 활용:** 반복적인 작업이나 데이터 추출(예: HTML에서 폰트 정보 추출, 빈 파일 생성 등)은 별도의 타입스크립트 스크립트로 작성하여 스킬이 이를 호출하게 만듭니다.
*   **찌꺼기 제거:** 스크립트를 통해 코드를 직접 실행하면, 중간 과정의 데이터(이미지 페이로드 등)가 컨텍스트 윈도우에 남지 않아 **컨텍스트 소모를 획기적으로 줄일 수 있습니다**.

### 4. 스킬 vs 에이전트 선택 기준
평소에 자주 사용하는 프롬프트를 아카이빙하다 보면, 이를 어떤 형태로 만들지 결정해야 합니다.
*   **프롬프트 아카이빙:** 자주 쓰는 명령어를 파일로 저장해 두고 범용적인 변수(`{{name}}` 등)를 추가합니다.
*   **결정:** 이 작업이 독립적인 정체성을 가진 '역할'에 가깝다면 **서브 에이전트**로, 특정 기능을 수행하는 '도구'에 가깝다면 **스킬**로 등록하여 활용합니다.
*   **MCP(Model Context Protocol)로 확장:** 아주 범용적이고 널리 쓰일 만한 도구(예: 이미지 배경 제거, 특정 코드 조회 등)는 **MCP**로 만들어 에이전트에게 쥐어줌으로써 생산성을 극대화합니다.

결론적으로 클로드 코드에서의 스킬 활용은 **'지능형 공구함'을 만드는 것**과 같습니다. 목수(에이전트)가 맨손으로 일하게 두지 않고, 상황에 맞는 전동 드릴이나 정밀 측정기(스킬 및 스크립트)를 직접 제작해 손에 쥐어줌으로써 혼자서도 거대한 건축물(대규모 프로젝트)을 빠르고 정확하게 완공할 수 있게 하는 원리입니다.


클로드 코드(Claude Code)에서 에이전트와 스킬을 체계적으로 관리하고 이를 공유하는 방법은 파일 기반의 구조를 활용하는 것이 핵심입니다. 소스에 나타난 최수민 개발자의 노하우를 바탕으로 관리 방법과 깃허브 저장 방식, 그리고 그 장단점을 정리해 드립니다.

### 1. 에이전트 및 스킬 폴더 관리와 오픈 방법
클로드 코드는 프로젝트 내의 특정 폴더 구조를 자동으로 인식하여 에이전트를 생성하고 관리합니다.

*   **에이전트 관리 폴더:** 프로젝트 루트에 **`claude/agents` 폴더**를 생성합니다. 
*   **에이전트 생성 (오픈):** 이 폴더 안에 **마크다운(.md) 파일**을 만들기만 하면 클로드 코드가 이를 서브 에이전트로 인식합니다. 별도의 복잡한 설정 없이 파일 생성만으로 에이전트가 '오픈'되어 즉시 호출 가능한 상태가 됩니다.
*   **스킬 관리:** 에이전트와 마찬가지로 자주 사용하는 스킬이나 시스템 파일들을 별도의 폴더(예: 최수민 개발자의 경우 `CC System` 저장소 구조 활용)에 모아 관리합니다. 
*   **프롬프트 아카이빙:** 평소 사용하는 프롬프트를 `prompts/`와 같은 별도 폴더에 파일로 저장해 두었다가, 필요할 때 이를 서브 에이전트의 지침으로 변환하여 사용합니다.

### 2. 깃허브(GitHub) 저장 및 활용 방법
에이전트와 스킬은 모두 텍스트 파일(MD, TS) 형태이므로 일반적인 소스 코드와 동일하게 깃허브로 관리할 수 있습니다.

*   **시스템 저장소 운영:** 최수민 개발자는 자신이 사용하는 시스템 파일과 스킬들을 **`CC System`이라는 별도의 깃허브 저장소**에 넣어 관리하며 이를 참조합니다.
*   **프로젝트 내 포함:** '모네(Mone)'와 같은 오픈소스 프로젝트의 경우, 프로젝트 저장소 내에 에이전트 설정 파일들을 직접 포함시켜 누구나 해당 프로젝트를 받으면 동일한 에이전트를 쓸 수 있게 공개합니다.
*   **버전 관리:** 에이전트의 지침을 수정할 때마다 깃(Git)으로 커밋하여, 에이전트가 과거에 어떻게 행동했는지 추적하고 개선된 버전을 유지합니다.

### 3. 장단점 분석

| 구분 | 주요 내용 및 분석 |
| :--- | :--- |
| **장점** | **1. 컨텍스트 최적화:** 에이전트를 세분화하고 스크립트와 결합하면 불필요한 데이터가 컨텍스트 윈도우에 남지 않아 더 깊고 복잡한 작업이 가능합니다. <br> **2. 압도적 생산성:** 한 번의 명령으로 100개 이상의 에이전트를 동시에 돌려 수백 개의 구현 사항을 한꺼번에 처리할 수 있습니다. <br> **3. 개인화된 최적화:** 반복되는 실수를 지침에 추가하며 자신에게 딱 맞는 '개인화된 에이전트 팀'을 구축할 수 있습니다. |
| **단점** | **1. 초기 진입 장벽:** 에이전트를 만드는 법 자체가 널리 알려지지 않았고, 처음 파이프라인을 구축할 때 시행착오가 발생할 수 있습니다. <br> **2. 협업의 어려움:** 에이전트가 개발자 개인의 스타일이나 특정 프롬프트에 최적화되어 있어, 타인이 해당 시스템에 기여하거나 그대로 활용하기에는 직관성이 떨어질 수 있습니다. |

결론적으로 클로드 코드의 관리 방식은 **'지능형 자동화 공정의 설계도'**를 관리하는 것과 같습니다. 파일 시스템을 통해 에이전트라는 '노동자'와 스킬이라는 '도구'를 폴더별로 배치하고, 이를 깃허브라는 '공용 창고'에 저장하여 언제든 꺼내 쓰거나 고도화할 수 있는 시스템입니다. 이러한 방식은 초기 구축에는 노력이 필요하지만, 일단 완성되면 혼자서도 거대한 조직처럼 움직이는 '1인 유니콘'의 기반이 됩니다.


초보자가 최수민 개발자와 같이 압도적인 생산성을 내는 '에이전틱 워크플로우'를 운영하기 위해 습득해야 할 기본 지식과 단계를 차례대로 설명해 드립니다.

### 1단계: 클로드 코드(Claude Code) 환경 이해
가장 먼저 기존의 단일 프롬프트 방식에서 벗어나 **에이전틱(Agentic) 기능**이 강력한 클로드 코드 도구에 익숙해져야 합니다.
*   **핵심 지식:** 클로드 코드는 에이전트가 또 다른 **서브 에이전트를 호출**하여 작업을 수행할 수 있는 구조를 가지고 있습니다.
*   **차이점 이해:** 커서(Cursor)와 같은 도구는 사용자가 매번 명령을 내려야 하지만, 클로드 코드는 한 번의 명령으로 여러 에이전트(조직의 팀과 같은 역할)를 동시에 움직여 복잡한 작업을 병렬로 처리할 수 있다는 점을 이해해야 합니다.

### 2단계: 서브 에이전트 구축 및 관리법
에이전트를 직접 설계하고 배치하는 능력을 길러야 합니다.
*   **파일 기반 관리:** 프로젝트 내의 **`claude/agents` 폴더**에 **마크다운(.md) 파일**을 생성하여 에이전트를 만드는 법을 익힙니다.
*   **필수 정의 요소:** 마크다운 파일 안에 **이름(Name), 설명(Description), 사용 도구(Tools), 사용할 모델(Model)**을 정의하는 규격에 익숙해져야 합니다. 예를 들어, 비용 절감을 위해 단순 작업에는 'Haiku' 모델을, 정교한 작업에는 'Opus'나 'Sonnet'을 지정하는 식입니다.

### 3단계: 컨텍스트 엔지니어링과 스크립트화
AI의 한정된 기억력(컨텍스트 윈도우)을 효율적으로 사용하는 기술이 가장 중요합니다.
*   **스크립트 결합:** 모든 일을 AI에게 말로 시키지 않고, 반복적인 파일 생성이나 데이터 추출은 **타입스크립트(TypeScript) 스크립트**로 작성하여 에이전트가 이를 실행하게 합니다.
*   **찌꺼기 제거:** 스크립트를 사용하면 이미지 페이로드나 불필요한 중간 과정이 컨텍스트에 남지 않아 더 깊고 많은 일을 지시할 수 있게 됩니다. 예를 들어 HTML에서 폰트를 추출하는 것과 같은 작업은 코드로 처리하는 것이 훨씬 빠르고 정확합니다.

### 4단계: 프롬프트 아카이빙 및 변수화
일회성 프롬프트가 아닌, 재사용 가능한 **자산**으로 만드는 습관이 필요합니다.
*   **프롬프트 폴더 운영:** 프로젝트에 별도의 프롬프트 폴더를 두고 자주 쓰는 지시문을 저장합니다.
*   **보명적 에이전트화:** 특정 프로젝트에 국한되지 않게 **변수(예: `{{name}}`)**를 사용하여, 어떤 상황에서도 호출해 쓸 수 있는 '범용 서브 에이전트'로 발전시키는 법을 배웁니다.

### 5단계: MCP(Model Context Protocol) 활용 및 확장
에이전트에게 강력한 '무기(도구)'를 쥐어주는 법을 익힙니다.
*   **MCP 구축:** 이미지 배경 제거(Sharp MCP)나 오픈소스 코드 조회와 같이 자주 쓰는 기능을 MCP로 만들어 에이전트가 자유롭게 쓰도록 합니다.
*   **도구의 외주화:** 범용적인 도구는 MCP로 배포하여 관리 효율을 높이고 정확도를 개선합니다.

### 6단계: 반복적 보강과 '도그푸딩' 철학
마지막으로, 기술을 넘어선 **제품 개발의 태도**를 갖춰야 합니다.
*   **피드백 루프:** 한 번에 완벽한 에이전트를 만들려 하지 말고, 실행 결과를 보고 에이전트가 자주 실수하는 부분(예: 태그 인식 오류 등)을 지침에 추가하며 계속 업데이트합니다.
*   **직접 사용(Dogfooding):** 자신이 겪는 불편함을 해결하기 위해 제품을 만듭니다. 본인이 첫 번째 사용자가 되어야 베드 시그널(Bad Signal)을 즉각 감지하고 에이전틱 워크플로우를 최적으로 다듬을 수 있습니다.

이러한 지식 습득 과정은 마치 **지능형 공장의 설계도**를 그리는 법을 배우는 것과 같습니다. 처음에는 작은 부품(프롬프트) 하나를 깎는 것부터 시작하지만, 나중에는 수많은 로봇 팔(서브 에이전트)과 자동화 라인(스크립트 및 파이프라인)을 구축하여 혼자서도 거대한 제품(1인 유니콘 프로젝트)을 생산해낼 수 있게 됩니다.



최수민 개발자는 클로드 코드의 **MCP(Model Context Protocol)**를 단순한 보조 도구를 넘어, 에이전트에게 강력한 기능을 부여하는 **'전용 무기'**로 활용하여 고도의 자동화를 구현하고 있습니다. 

그가 MCP를 활용해 자동화를 달성한 구체적인 방식과 사례는 다음과 같습니다.

### 1. 컨텍스트 효율화를 위한 '데이터 처리 외주화'
최수민 개발자가 MCP를 사용하는 가장 큰 기술적 이유는 **컨텍스트 윈도우(AI의 기억 공간) 관리**입니다. 
*   **문제점:** 에이전트에게 직접 이미지 생성이나 복잡한 데이터 분석을 시키면, 그 과정에서 발생하는 이미지 페이로드 등 불필요한 '찌꺼기' 데이터가 컨텍스트 윈도우에 남게 되어 AI의 지능이 금방 떨어집니다.
*   **해결책:** 반복적이고 데이터 소모가 큰 작업을 MCP로 분리합니다. 이렇게 하면 에이전트는 도구를 호출해 결과만 전달받으므로 컨텍스트를 깨끗하게 유지하면서 더 복잡한 추론에 집중할 수 있습니다.

### 2. 구체적인 MCP 활용 사례
최수민 개발자는 자신의 생산성을 극대화하기 위해 다음과 같은 전용 MCP들을 직접 만들어 에이전트에게 쥐어주었습니다.

*   **샤프 MCP (Sharp MCP):** 이미지의 **배경을 자동으로 제거**해 주는 도구입니다. 개발자가 일일이 작업하기 번거로운 디자인 업무를 MCP로 만들어 에이전트가 스스로 처리하게 했습니다.
*   **오픈소스 코드 조회 MCP:** 참고하고 싶은 다른 오픈소스의 코드를 에이전트가 직접 조회하여 학습하고 적용할 수 있게 돕습니다.
*   **나노바나(Nano-vana) MCP:** 프로젝트 진행 중 자주 호출해야 하는 특정 서비스(나노바나)를 MCP로 연결하여 에이전트가 필요할 때마다 즉시 기능을 수행하도록 했습니다.
*   **컬렉션 기반 랜딩 페이지 생성 MCP:** '모네' 프로젝트에서 수집된 디자인 컴포넌트 컬렉션을 읽어와, 이를 바탕으로 **랜딩 페이지 한 판을 통째로 만들어내는** 고도화된 자동화를 수행합니다.

### 3. 범용적 도구의 자산화
그는 단순히 혼자 쓰는 것에 그치지 않고, 성능이 검증된 스크립트 중 범용적인 것을 MCP로 배포합니다.
*   **오픈소스화의 장점:** MCP를 오픈소스로 공개하면 다른 사용자들이 버그를 고쳐주거나 제보해 주어, 도구의 완성도가 높아지는 **선순환 구조**가 만들어집니다.
*   **에이전트의 성장:** 결과적으로 개발자는 에이전트에게 더 날카롭고 정교한 도구(MCP)를 계속 추가해 주며 본인만의 최적화된 에이전트 팀을 구축하게 됩니다.

이러한 MCP 활용법은 마치 **숙련된 목수가 전동 공구함을 갖추는 것**과 같습니다. 목수(에이전트)가 맨손으로 나무를 깎게 하는 대신, 상황에 맞는 정밀한 전기톱이나 드릴(MCP)을 직접 제작해 손에 쥐어줌으로써, 혼자서도 대규모 건축물(100개의 서비스 런칭)을 빠르고 정확하게 완성할 수 있는 시스템을 구축한 것입니다.


소스에 따르면, 최수민 개발자는 전통적인 방식의 API 호출을 넘어 **MCP(Model Context Protocol)와 스크립트**를 활용해 외부 서비스나 특정 기능을 에이전트와 연결하는 방식으로 자동화를 구현하고 있습니다. 구체적인 활용 사례는 다음과 같습니다.

### 1. 전용 서비스를 연결하는 MCP 활용
특정 서비스나 복잡한 기능을 에이전트가 직접 수행하게 하기 위해 MCP를 도구(Tool) 형태로 연결하여 사용합니다.
*   **나노바나(Nano-vana) MCP:** 프로젝트 진행 중 **나노바나 서비스를 호출**해야 할 일이 많아 이를 MCP로 만들어 에이전트가 필요할 때마다 즉시 기능을 수행하도록 연결했습니다.
*   **샤프 MCP (Sharp MCP):** 이미지의 **배경을 제거하는 외부 기능**을 MCP로 구현하여 에이전트에게 쥐어줌으로써, 디자인 업무를 자동화했습니다.
*   **오픈소스 코드 조회 MCP:** 외부의 **오픈소스 저장소 코드를 조회**하여 에이전트가 참고하고 학습할 수 있도록 기능을 연결했습니다.

### 2. 스크립트를 통한 데이터 추출 및 연동
API와 유사하게 특정 데이터를 뽑아오거나 처리하는 과정을 타입스크립트(TypeScript) 스크립트로 구현하여 에이전트가 호출하게 합니다.
*   **리소스 추출 자동화:** 가상 브라우저를 실행해 특정 URL에서 **스크린샷이나 리소스를 추출**하는 로직을 스크립트화하여 에이전트가 실행하도록 합니다.
*   **HTML 데이터 파싱:** HTML 파일에서 **폰트 정보 등을 추출**하는 작업을 코드로 처리하여 속도와 정확도를 높입니다.

### 3. 마케팅 및 운영 자동화 사례
100개의 서비스를 효율적으로 운영하기 위해 마케팅 채널과의 연동 및 자동화를 계획하거나 실행 중입니다.
*   **블로그 자동화 솔루션 (Vibe Blog):** 100개 서비스의 SEO를 위해 **키워드를 수집하고 블로그 글을 써주는 자동화 솔루션**을 기획하여 적용할 예정입니다.
*   **마케팅 퍼널 연동:** 수동으로 SNS를 관리할 수 없기 때문에 **SNS 게시물 업로드 및 이메일 마케팅 퍼널**을 자동화 시스템으로 구축하여 운영하고자 합니다.

### 4. 에이전트 간의 상호 호출 (Internal API)
에이전트가 단순히 명령을 받는 것에 그치지 않고, 내부적으로 다른 전문 에이전트를 호출하는 '계층적 구조'를 사용합니다.
*   **병렬 호출:** 하나의 메인 지침(MD 파일)에 따라 **URL2Page 에이전트** 등이 호출되고, 이 서브 에이전트가 다시 다른 에이전트를 병렬로 호출하여 125개의 구현 사항을 한 번에 처리하기도 합니다.

이러한 방식은 마치 **"에이전트에게 전용 무전기(MCP)와 자동화 공구(스크립트)를 쥐어주는 것"**과 같습니다. 에이전트가 모든 것을 스스로 추론하게 하지 않고, 검증된 기능(API/스크립트)을 필요할 때마다 호출하게 함으로써 대규모 작업을 오류 없이 자동화할 수 있게 됩니다.


최수민 개발자가 '모네' 프로젝트와 100여 개의 서비스 런칭을 목표로 활용하고 있는 **클로드 코드(Claude Code)**의 핵심 기능들과 그 장단점, 그리고 이를 효과적으로 활용하는 방법은 다음과 같습니다.

### 1. 클로드 코드의 핵심 자동화 기능 및 장단점 분석

| 기능명 | 주요 역할 및 특징 | 장점 | 단점 |
| :--- | :--- | :--- | :--- |
| **서브 에이전트 (Sub-agents)** | 특정 작업을 수행하는 독립된 전문 AI 요원을 생성합니다. | 한정된 컨텍스트 내에서 더 깊고 많은 일을 병렬로 처리할 수 있습니다,. | 초기 설정(MD 파일 생성)이 필요하며, 타인이 구조를 한눈에 파악하기 어려울 수 있습니다,. |
| **스크립트화 (Scripting)** | 반복적이고 규칙적인 작업을 타입스크립트(TS) 코드로 처리합니다. | 정확도와 속도가 비약적으로 향상되며, 컨텍스트 내 '찌꺼기'를 남기지 않습니다. | 코딩 지식(TypeScript)이 필요하며, 모든 과정을 수동으로 스크립트화해야 하는 번거로움이 있습니다. |
| **MCP (Model Context Protocol)** | 이미지 배경 제거, 코드 조회 등 외부 도구를 에이전트에게 제공합니다. | 에이전트의 기능을 무한히 확장할 수 있으며, 오픈소스화하여 성능을 개선할 수 있습니다. | 프로토콜에 맞춘 초기 개발 공수가 들며, 시스템이 복잡해질 수 있습니다. |
| **파이프라인 문서화 (Pipeline MD)** | 전체 작업의 순서와 에이전트 호출 순서를 정의한 설계도입니다,. | 인풋 하나만으로 수백 개의 작업을 자동 수행하는 거대한 공정을 만들 수 있습니다,. | 파이프라인 설계 자체가 고도의 논리력을 요구하며, 시행착오가 필수적입니다. |

---

### 2. 후학들을 위한 클로드 코드 활용 전략

최수민 개발자의 노하우를 바탕으로, 에이전틱 워크플로우를 처음 시작하는 분들을 위한 가이드입니다.

**① 프롬프트 아카이빙부터 시작하세요**
에이전트를 바로 만들기보다, 평소 자주 사용하는 프롬프트를 별도의 폴더(`prompts/`)에 파일로 저장하는 습관을 들이는 것이 좋습니다. 이후 이 프롬프트에서 변수화할 부분(예: `{{name}}`)만 지정하면 즉시 범용 서브 에이전트로 전환할 수 있습니다.

**② '지능'과 '도구'를 분리하세요**
모든 것을 AI의 추론(LLM)에만 맡기지 마세요. 빈 파일을 만들거나 HTML에서 특정 정보를 추출하는 일처럼 규칙이 명확한 작업은 **스크립트(TypeScript)**로 작성하여 에이전트가 호출하게 해야 합니다,. 이는 AI의 기억력(컨텍스트)을 아끼고 결과물의 정확도를 높이는 핵심 비결입니다.

**③ 점진적으로 개선하는 '피드백 루프'를 만드세요**
처음부터 완벽한 파이프라인을 구축할 수는 없습니다. 에이전트가 특정 작업(예: 폰트 두께 설정 등)에서 계속 실수를 한다면, 그 결과를 보고 지침을 조금씩 보강하며 **자신에게 최적화된 개인화된 에이전트**로 진화시켜야 합니다.

**④ 직접 사용할 제품을 만드세요 (도그푸딩)**
본인이 사용할 도구를 만들 때 불편함을 가장 빠르게 캐치할 수 있습니다,. 자신이 첫 번째 사용자가 되어 배드 시그널(Bad Signal)을 감지하고 이를 자동화로 해결해 나가는 과정이 곧 실력이 됩니다.

**⑤ 서브 에이전트 크리에이터를 구축하세요**
숙련도가 쌓이면 에이전트의 공식 문서를 학습시킨 뒤, "이런 역할을 하는 서브 에이전트를 만들어줘"라고 명령하면 자동으로 MD 파일을 생성해 주는 **'에이전트를 만드는 에이전트'**를 구축하여 생산성을 극대화할 수 있습니다.

이러한 클로드 코드 활용법은 마치 **'숙련된 장인이 자신만의 자동화 공장을 설계하는 것'**과 같습니다. 처음에는 수동으로 망치질(프롬프팅)을 하던 단계에서 벗어나, 각 공정별로 로봇 팔(서브 에이전트)을 배치하고 정밀 도구(MCP/스크립트)를 쥐어줌으로써, 혼자서도 수백 명의 팀원이 움직이는 유니콘 기업과 같은 퍼포먼스를 낼 수 있게 됩니다.



최수민님은 아래 질문사항에 어떻게 답변을 줄 수 있을까 "Q1. 에이전트 실수를 어떻게 "발견"하시나요?
- 직접 결과물을 하나하나 확인하시는지?
- 자동 검증 스크립트가 있는지?
- 에러 로그를 따로 수집하시는지?


Q2. 피드백을 기록할 때 어떤 포맷을 쓰시나요?
- 마크다운? JSON? 노션?
- 실제 피드백 파일 예시를 볼 수 있을까요?


Q3. "이 정도면 충분히 개선됐다"는 기준이 있나요?
- 몇 번 정도 반복하면 안정화되는지?"

최수민 개발자가 '모네' 프로젝트와 100여 개의 서비스 자동화 과정에서 경험한 내용을 바탕으로, 질문하신 에이전트 관리 및 개선 방식에 대해 다음과 같이 답변을 드릴 수 있습니다.
Q1. 에이전트 실수를 어떻게 "발견"하시나요?
최수민 개발자는 주로 **직접 결과물을 확인하는 방식(도그푸딩)**과 검증 로직이 포함된 스킬을 통해 실수를 발견합니다.
• 직접 결과물 확인 (도그푸딩): 최수민 개발자는 "자신이 쓸 제품을 만들면 쓰다 보니까 되게 빠르게 불편함을 캐치할 수 있다"고 강조합니다. 파이프라인을 처음 실행하면 무조건 결과가 이상하게 나오기 마련인데, 이때 어떤 부분이 약하게 지시되었는지 직접 보고 판단합니다.
• 실행 결과의 이상 감지: 에이전트가 폰트 두께(font weight)를 계속 틀리거나 태그를 제대로 잡지 못하는 등의 구체적인 실수는 결과물을 모니터링하며 발견합니다.
• 자동 검증 로직: 스킬을 만들 때 검증(Validation)을 할 수 있는 로직을 포함하도록 설정하여, 에이전트가 작업을 마친 후 스스로 규칙에 맞게 수행했는지 확인하게 하기도 합니다.
Q2. 피드백을 기록할 때 어떤 포맷을 쓰시나요?
피드백은 별도의 문서에 기록하기보다, 에이전트의 지침 파일(Markdown)에 직접 반영하여 에이전트의 지능을 개선하는 방식으로 관리합니다.
• 마크다운(Markdown) 포맷: 클로드 코드의 claude/agents 폴더 내에 있는 .md 파일이 곧 에이전트의 정의서이자 피드백 기록장입니다.
• 실제 피드백 반영 예시:
    ◦ 에이전트가 태그를 잘 못 잡는 실수를 하면, 해당 에이전트의 마크다운 지침에 **"태그에 대한 지침을 추가해라"**와 같은 내용을 넣습니다. 소스에 따르면 실제 에이전트 지침 중에는 AI가 스스로 추가한 내용도 포함되어 있어, 피드백이 실시간으로 지침에 녹아들게 합니다.
    ◦ 자주 사용하는 프롬프트는 별도의 prompts/ 폴더에 아카이빙해 두었다가, 이를 기반으로 서브 에이전트의 Description이나 지침을 수정합니다.
Q3. "이 정도면 충분히 개선됐다"는 기준이 있나요?
정해진 횟수보다는 결과물의 안정성과 속도를 기준으로 판단하며, 지속적인 보강 과정을 거칩니다.
• 결과물의 만족도: "내용이 마음에 안 들거나 너무 느리다고 느껴지면 조금씩 더 보강한다"는 원칙을 가집니다.
• 반복을 통한 안정화: 고수라도 한 번에 완벽한 지침을 만들 수 없으므로, 실행 후 이상한 점이 발견되지 않을 때까지 "조금씩 보강해 나가는 과정" 자체를 안정화 단계로 봅니다.
• 대규모 처리 가능 여부: 지침이 충분히 개선되었다고 판단되면, 125개의 구현 사항을 한 번에 명령해도 오류 없이 수행할 수 있는 수준에 도달하게 됩니다.
결론적으로 최수민 개발자는 **"완벽한 설계보다는 실행 후 수정을 통한 진화"**를 중시합니다. 처음부터 완벽한 매뉴얼을 쓰려 하기보다, 현장에서 일하는 에이전트의 실수를 보고 매뉴얼(마크다운 지침)을 한 줄씩 추가하며 최적화된 팀을 만들어가는 방식입니다.
비유하자면, 이는 처음부터 완벽한 요리 레시피를 적는 것이 아니라, 요리를 직접 먹어보며(도그푸딩) "조금 더 짜게", "불은 더 약하게"라는 메모를 레시피 옆에 계속 추가하여 결국 누구나 같은 맛을 낼 수 있는 완성된 레시피를 만드는 과정과 같습니다.
최수민 개발자가 커서 대신 클로드 코드를 사용하는 기술적 이유는?
클로드 코드에서 서브 에이전트를 생성하고 구동하는 구체적인 방법은?
에이전트 개발 시 컨텍스트 소모를 줄이기 위해 제안된 전략은?
Q4. "이건 스크립트로 빼야겠다"고 결정하는 기준이 뭔가요?
- 반복 횟수? (예: 3번 이상 반복되면?)
- 컨텍스트 소모량?
- 정확도 문제?


Q5. 스크립트와 에이전트 사이의 데이터 전달은 어떻게 하시나요?
- 파일로 저장? JSON으로 반환?
- 실제 코드 예시가 있으면 좋겠어요

최수민 개발자가 작업을 에이전트의 직접 수행 대신 스크립트(TypeScript 등)로 전환하는 기준과 데이터 전달 방식에 대한 답변은 다음과 같습니다.
Q4. "이건 스크립트로 빼야겠다"고 결정하는 기준이 뭔가요?
최수민 개발자는 단순히 반복 횟수뿐만 아니라, AI의 효율성과 작업의 성격을 고려하여 스크립트화 여부를 결정합니다. 주요 기준은 세 가지입니다.
1. 컨텍스트 소모량 (최우선 기준):
    ◦ 에이전트가 직접 파일을 생성하거나 이미지 데이터를 처리하게 하면, 그 과정에서 발생하는 **'데이터 찌꺼기(이미지 페이로드 등)'**가 컨텍스트 윈도우에 남게 됩니다.
    ◦ 이로 인해 컨텍스트가 빨리 소모되어 AI의 지능이 떨어지는 것을 방지하기 위해, 중간 과정은 스크립트로 처리하고 최종 결과물만 컨텍스트에 남도록 설계합니다.
    ◦ 내용이 없는 **'빈 깡통 파일'**들을 대량으로 만드는 작업도 에이전트가 직접 할 필요가 없으므로 스크립트로 뺍니다.
2. 정확도와 속도:
    ◦ HTML 파일에서 특정 폰트 정보를 추출하는 것과 같이 규칙이 명확한 작업은 LLM의 추론보다 코드로 처리하는 것이 훨씬 정확하고 속도도 빠릅니다.
3. 범용성:
    ◦ 작성한 스크립트 중 매우 범용적이고 자주 쓰이는 기능은 별도의 **MCP(Model Context Protocol)**로 만들어 에이전트에게 상시 도구로 쥐어줍니다.

--------------------------------------------------------------------------------
Q5. 스크립트와 에이전트 사이의 데이터 전달은 어떻게 하시나요?
소스에 따르면 데이터 전달은 주로 파일 생성 및 파이프라인을 통한 종합 방식으로 이루어집니다.
1. 결과물 기반 전달 (File-based):
    ◦ 에이전트가 스크립트를 실행하면, 스크립트는 가상 브라우저를 띄워 스크린샷을 찍거나 리소스를 추출하여 파일로 저장합니다.
    ◦ 이렇게 하면 에이전트는 대화창 안에서 무거운 데이터를 직접 주고받지 않고도, 생성된 파일을 확인하여 다음 단계(예: 컴포넌트화)를 수행할 수 있습니다.
2. 파이프라인을 통한 종합:
    ◦ **MD 파일(설계도)**에 작업 순서를 미리 정의해 둡니다. 예를 들어, '에이전트 A가 스크립트를 실행해 리소스를 분석하면, 그 결과를 바탕으로 에이전트 B가 레지스트리를 업데이트한다'는 식의 흐름을 만듭니다.
    ◦ 최종적으로는 각 섹션별로 처리된 결과물들을 하나로 모아 최종 결과물 종합(Synthesis) 단계를 거칩니다.
3. 실제 활용 예시 (로직 기준):
    ◦ URL2Page 에이전트: URL을 입력받으면 스크립트를 호출해 해당 웹사이트의 리소스를 파싱하고, 그 결과를 파일 형태로 정리하여 다음 에이전트에게 넘깁니다.
    ◦ 컴포넌트 레지스트리 업데이트: 스크립트가 분석한 데이터를 바탕으로 에이전트가 프로젝트 내의 레지스트리 파일을 읽고 써서 정보를 동기화합니다.
요약하자면, 최수민 개발자는 AI에게 **"모든 일을 머리(추론)로 풀게 하지 않고, 정해진 공식은 계산기(스크립트)를 써서 결과값(파일)만 보고하게 만드는 방식"**으로 데이터를 전달하고 관리합니다. 이렇게 함으로써 컨텍스트를 깨끗하게 유지하며 100개가 넘는 에이전트를 동시에 가동할 수 있는 환경을 구축했습니다.
클로드 코드가 커서 등 다른 툴보다 압도적인 이유는 무엇인가요?
서브 에이전트를 생성할 때 마크다운 파일에 정의해야 할 요소는?
최수민 개발자가 '100개 서비스 런칭' 목표를 세운 전략적 이유는?
Q6. 125개 구현 사항을 한 번에 처리한다고 하셨는데,
실제로 어떻게 "동시에" 돌리시나요?
- 터미널 여러 개?
- 스크립트로 병렬 호출?
- Claude Code 내장 기능?


Q7. 병렬 처리 중 일부가 실패하면 어떻게 처리하시나요?
- 전체 롤백?
- 실패한 것만 재시도?
- 에러 무시하고 계속?

최수민 개발자가 클로드 코드(Claude Code)를 통해 125개의 구현 사항을 한 번에 처리하고 오류를 관리하는 방식에 대해 소스 내용을 바탕으로 답변해 드리겠습니다.
Q6. 125개 구현 사항을 한 번에 "동시에" 처리하는 방법
최수민 개발자가 수백 개의 에이전트를 가동하는 것은 단순히 터미널을 여러 개 띄우는 수동적인 방식이 아니라, 클로드 코드의 에이전틱(Agentic) 구조와 파이프라인 설계를 통한 자동화입니다.
• 에이전트 간의 계층적 병렬 호출: 클로드 코드의 가장 큰 장점은 에이전트가 또 다른 서브 에이전트를 호출할 수 있다는 점입니다. 사용자가 하나의 명령(인풋)을 내리면, 메인 에이전트가 파이프라인(MD 파일)에 정의된 지침에 따라 여러 서브 에이전트를 **병렬로 호출(Parallel Call)**하여 작업을 수행합니다.
• 배치(Batch) 처리 프롬프트 활용: 125개와 같은 대량의 작업을 처리할 때는 한 번에 모든 것을 시키기보다 효율적인 배치 반복 방식을 씁니다. 예를 들어, "체크리스트에서 구현되지 않은 항목을 최대 20개씩 구현하고 다음 배치를 반복하라"는 식의 프롬프트를 사용하여 전체 125개를 한 번의 요청으로 끝까지 완수하게 만듭니다.
• 파이프라인 문서화: 어떤 에이전트를 쓰고 어떤 순서로 작업할지를 MD 파일에 미리 정의해 둡니다. 이 '설계도'가 있기 때문에 클로드 코드가 조직장처럼 여러 팀(서브 에이전트)을 한꺼번에 움직여 복잡한 기능을 동시에 구현할 수 있는 것입니다.
Q7. 병렬 처리 중 일부가 실패했을 때의 처리 방식
소스에 따르면 최수민 개발자는 시스템적인 '롤백'보다는 **결과물 검증과 지침 보강(Feedback Loop)**을 통해 실패를 관리합니다.
• 최종 결과물 종합 (Synthesis): 파이프라인의 마지막 단계에는 항상 최종 결과물 종합 단계가 있습니다. 각 서브 에이전트가 병렬로 만든 결과물들을 하나로 모으는 과정에서 누락되거나 잘못된 부분을 확인합니다.
• 피드백 루프를 통한 지침 업데이트: 에이전트가 특정 부분(예: 태그 인식, 폰트 설정 등)에서 실수를 하면, 이를 단순히 수정하고 끝내는 것이 아니라 해당 에이전트의 마크다운(.md) 지침 파일에 실수 방지 문구를 추가합니다. 이렇게 하면 다음 실행 시 동일한 실패가 발생하지 않도록 에이전트 자체가 '진화'하게 됩니다.
• 검증 로직 포함: 스킬을 설계할 때부터 **작업이 잘 되었는지 스스로 검증(Validation)**할 수 있는 로직을 걸어두어, 에이전트가 작업 완료 후 규칙 준수 여부를 체크하도록 만듭니다.
요약하자면, 최수민 개발자는 클로드 코드를 **'여러 팀원이 동시에 움직이는 거대한 조직'**처럼 운영합니다. 한 번의 명령으로 수많은 서브 에이전트가 병렬로 흩어져 일하게 하고(Q6), 발생한 오류는 에이전트의 '업무 매뉴얼(MD 파일)'을 지속적으로 수정함으로써 시스템 전체의 완성도를 높이는 방식으로 해결합니다(Q7).
이 방식은 마치 숙련된 공장장(개발자)이 자동화 생산 라인(파이프라인)을 설계하고, 각 공정의 로봇(에이전트)이 실수를 할 때마다 센서 설정(지침)을 미세 조정하여 불량률을 제로에 가깝게 줄여나가는 과정과 같습니다.
클로드 코드가 커서 등 다른 툴보다 압도적인 이유는 무엇인가요?
서브 에이전트를 생성하기 위해 필요한 파일 형식은 무엇인가요?
컨텍스트 소모를 줄이기 위해 반복 작업을 처리하는 방법은 무엇인가요?
Q8. 컨텍스트 윈도우가 부족해지는 걸 어떻게 감지하시나요?
- 체감으로? (응답이 이상해지면?)
- 토큰 수 모니터링?
- 특정 증상이 있나요?


Q9. 대화가 길어졌을 때 "리셋"하는 타이밍이 있나요?
- 몇 턴 정도에서?
- 어떤 기준으로?

최수민 개발자는 한정된 컨텍스트 윈도우 안에서 효율을 극대화하기 위해 '감지'보다는 **'구조적 예방'**에 집중하는 방식을 취합니다. 소스 내용을 바탕으로 질문에 대해 답변해 드립니다.
Q8. 컨텍스트 윈도우가 부족해지는 걸 어떻게 감지하시나요?
최수민 개발자는 특정 수치를 모니터링하기보다, 작업의 규모와 에이전트의 반응을 통해 한계를 감지합니다.
• 한계 체감: 바이브 코딩을 하다 보면 조금만 큰 작업을 시켜도 컨텍스트 사이즈가 부족해지는 현상을 직접 한계로 느끼게 됩니다. 예를 들어, 커서(Cursor) 같은 도구에서는 한 번의 요청으로 작업을 다 끝내지 못하고 멈추는 경우가 발생합니다.
• 특정 증상(데이터 찌꺼기): 에이전트에게 이미지 처리나 파일 생성을 직접 시키면, 그 과정에 필요한 데이터들이 컨텍스트 윈도우에 고스란히 남게 됩니다. 이렇게 **이미지 페이로드와 같은 '불필요한 찌꺼기'**가 쌓이면 컨텍스트가 매우 빠르게 소모되며, 이로 인해 에이전트의 지능이 떨어지거나 작업을 완수하지 못하는 증상이 나타납니다.
• 작업의 복잡도: 773개의 컴포넌트를 만드는 것과 같이 물리적으로 양이 많은 작업을 단일 프롬프트로 처리하려 할 때 컨텍스트의 한계가 명확히 드러납니다.
Q9. 대화가 길어졌을 때 "리셋"하는 타이밍이 있나요?
최수민 개발자는 단순히 대화를 리셋하기보다, **'서브 에이전트 분리'와 '스크립트화'**를 통해 컨텍스트를 상시 최적화합니다.
• 분리 타이밍 (기준): 컨텍스트 사이즈 때문에 작업에 한계를 느낄 때가 바로 서브 에이전트로 나눌 타이밍입니다. 작업을 에이전트별로 나누면 컨텍스트를 독립적으로 사용할 수 있어 전체 프로젝트 관점에서는 컨텍스트를 극대화하는 효과가 있습니다.
• 스크립트 전환 기준: 반복적으로 많은 파일을 생성해야 하거나 데이터를 분석해야 할 때, 이를 에이전트가 직접 수행하게 하지 않고 타입스크립트 스크립트로 전환합니다. 스크립트를 실행하고 결과물만 남기면 중간 과정의 데이터가 컨텍스트에 남지 않아 사실상 **'부분적 리셋'**과 같은 효과를 봅니다.
• 최종 결과물 종합: 파이프라인의 마지막에 최종 결과물 종합(Synthesis) 단계를 두어, 파편화된 작업들을 정리함으로써 컨텍스트 효율을 높이고 긴 대화의 흐름을 마무리합니다.
요약하자면, 최수민 개발자에게 컨텍스트 관리는 **'방 청소'**와 같습니다. 물건(데이터)이 쌓여 발 디딜 틈이 없을 때(컨텍스트 부족) 청소하는 것이 아니라, 처음부터 쓰레기가 생기지 않도록 외부 창고(스크립트)를 활용하고, 방을 여러 개(서브 에이전트)로 나누어 각 방이 항상 깨끗하고 넓은 상태를 유지하게 만드는 전략을 사용합니다.
클로드 코드가 커서보다 에이전틱 기능에서 압도적인 이유는 무엇인가?
클로드 코드에서 서브 에이전트를 생성하는 구체적인 방법은 무엇인가?
에이전트 작업 과정에서 컨텍스트 소모를 줄이는 스크립트화 전략은 무엇인가?
Q10. 스킬 vs MCP, 어떤 기준으로 나누시나요?
- "이건 스킬로", "이건 MCP로" 결정하는 기준?


Q11. MCP를 만들 때 가장 신경 쓰는 부분이 뭔가요?
- 입출력 설계?
- 에러 처리?
- 다른 도구와의 호환성?

최수민 개발자가 클로드 코드(Claude Code)를 활용하면서 스킬과 MCP를 구분하는 기준과 제작 시 중요하게 여기는 요소는 다음과 같습니다.
Q10. 스킬 vs MCP, 어떤 기준으로 나누시나요?
스킬과 MCP를 나누는 가장 결정적인 기준은 **'범용성'**과 **'공유 가능성'**입니다.
• 스크립트 및 스킬: 특정 프로젝트 내에서 반복되는 작업을 자동화하거나, 에이전트가 수행할 구체적인 로직(예: 빈 파일 생성, 특정 데이터 추출)을 구현할 때 사용합니다. 예를 들어, 에이전트를 만드는 '서브 에이전트 크리에이터'는 스킬로 만들어 사용합니다.
• MCP (Model Context Protocol): 스크립트화한 기능 중 **"엄청 범용적인 것"**은 MCP로 제작합니다.
    ◦ 결정 기준: 해당 기능이 다른 프로젝트에서도 널리 쓰일 수 있는지, 혹은 다른 사용자들에게도 유용한 '도구'인지를 판단합니다.
    ◦ 사례: 이미지 배경을 제거하는 '샤프 MCP', 오픈소스 코드를 조회하는 MCP, 특정 서비스(나노바나)를 호출하는 MCP 등이 이에 해당합니다.
Q11. MCP를 만들 때 가장 신경 쓰는 부분이 뭔가요?
최수민 개발자는 MCP나 스킬을 설계할 때 **'정확성'**과 **'지속 가능한 개선'**에 가장 큰 비중을 둡니다.
• 공식 문서 기반의 정확한 설계: 새로운 도구를 만들 때 클로드 코드의 공식 문서를 마크다운으로 저장해 두고, 이를 AI가 참고하게 하여 규격에 맞는 도구를 생성하도록 합니다.
• 검증(Validation) 로직 포함: 도구를 추가하거나 실행할 때 "검증도 할 수 있게" 설정을 걸어두는 것을 중요하게 생각합니다. 이는 에이전트가 도구를 사용할 때 발생할 수 있는 오류를 최소화하기 위함입니다.
• 오픈소스화를 통한 피드백 루프: MCP를 배포할 때 가장 큰 장점으로 꼽는 것은 사용자들의 제보와 수정입니다. 자신이 만든 MCP에 버그가 있다면 오픈소스 커뮤니티에서 이를 고쳐주거나 제보해 줄 것이기 때문에, 이를 통해 도구의 완성도를 높이는 선순환 구조를 신경 씁니다.
• 컨텍스트 윈도우 최적화: MCP가 실행되는 과정에서 불필요한 이미지 페이로드나 데이터 찌꺼기가 컨텍스트 윈도우에 남지 않도록 설계하여, 에이전트의 지능이 유지되도록 하는 것에 집중합니다.
요약하자면, 최수민 개발자에게 **스킬은 '우리 집 전용 맞춤 가구'**와 같고, **MCP는 '시장에 내놓아도 누구나 쓸 수 있는 표준 공구'**와 같습니다. 따라서 MCP를 만들 때는 누구나 믿고 쓸 수 있도록 표준 문서에 따른 정확한 설계와 커뮤니티의 피드백을 받을 수 있는 구조를 가장 신경 씁니다.
클로드 코드가 다른 코딩 툴보다 압도적인 이유는 무엇인가요?
서브 에이전트를 생성할 때 필요한 파일 형식은 무엇인가요?
최수민님이 100개 서비스 런칭을 목표로 세운 이유는 무엇인가요?
Q12. opus/sonnet/haiku 모델 선택 기준이 궁금해요
- 작업 복잡도로만 판단하시는지?
- 비용 대비 품질 기준이 있는지?
- 실제로 haiku로 충분한 작업 예시?


Q13. 한 달 API 비용이 대략 어느 정도 나오나요?
- 100개 서비스 운영 시 예상 비용?

최수민 개발자가 클로드 코드(Claude Code)를 운영하며 모델을 선택하는 기준과 그에 따른 비용 관리에 대해 소스의 내용을 바탕으로 답변해 드립니다.
Q12. Opus / Sonnet / Haiku 모델 선택 기준
최수민 개발자는 각 서브 에이전트의 역할과 작업의 난이도에 따라 모델을 전략적으로 배분합니다.
• 작업 복잡도에 따른 판단: 서브 에이전트를 정의할 때 model 항목을 직접 지정할 수 있는데, **어려운 작업에는 비싼 모델(Opus)**을, 단순하거나 **저렴하게 처리할 수 있는 작업에는 하이쿠(Haiku)**를 선택합니다.
• 비용 대비 품질 기준: 모든 작업을 고성능 모델로 처리하지 않고, 에이전트의 지침(Markdown)에서 모델을 명시하여 효율을 높입니다.
• Haiku로 충분한 작업 예시: 소스에서 구체적인 하이쿠 전용 작업 리스트를 나열하지는 않았으나, **"가장 저렴한 것"**으로 처리해도 되는 반복적이고 정형화된 작업들이 이에 해당합니다. 예를 들어, 복잡한 추론이 필요 없는 프롬프트 아카이빙이나 단순 체크리스트 생성 등은 하이쿠로도 충분히 운영 가능할 것으로 보입니다.
Q13. 한 달 API 비용 및 100개 서비스 운영 예상 비용
최수민 개발자는 현재 높은 생산량을 유지하면서도 클로드 코드의 요금 체계 내에서 비용을 관리하고 있습니다.
• 현재 지출 비용: 현재 200달러(약 27~28만 원)짜리 요금제를 사용하고 있습니다. 그는 구현하는 양 자체가 워낙 많다 보니 이 요금제를 거의 꽉 채워서 사용하고 있으며, 남은 용량은 수백 개의 에이전트를 한꺼번에 돌리는 데 활용합니다.
• 100개 서비스 운영 시 예상 비용: 구체적인 총액이 명시되지는 않았지만, 최수민 개발자는 다음과 같은 방식으로 비용 효율을 극대화하여 100개 서비스를 운영할 계획입니다.
    ◦ 스크립트화: 중간 과정을 타입스크립트 코드로 처리하여 컨텍스트 소모를 줄임으로써 API 비용을 절감합니다.
    ◦ 수익화를 통한 상쇄: 그는 각 서비스가 **패시브 인컴(Passive Income)**을 창출하도록 설계하여, 별도의 경제 활동 없이도 요금제와 생계비를 충분히 충당할 수 있는 구조를 만들고 있습니다.
    ◦ 운영 자동화: 100개 서비스를 사람이 일일이 관리하면 비용과 시간이 감당 안 되기 때문에, SNS 업로드, 이메일 마케팅 퍼널, 블로그 SEO 등을 완전히 자동화하여 1인 운영이 가능한 구조로 설계했습니다.
결론적으로, 최수민 개발자의 모델 선택은 **'적재적소의 인력 배치'**와 같습니다. 고도의 전략이 필요한 일은 수석 컨설턴트(Opus)에게, 단순 반복 업무는 아르바이트생(Haiku)에게 맡겨 전체 비용을 최적화하는 방식입니다. 이를 통해 월 200달러 수준의 구독료로도 100개의 서비스를 생산하고 관리하는 '1인 유니콘'의 퍼포먼스를 내고 있습니다.
클로드 코드의 서브 에이전트를 생성하는 구체적인 방법은 무엇인가요?
서브 에이전트 활용 시 컨텍스트 소모를 줄이는 전략은 무엇인가요?
커서와 비교하여 클로드 코드가 가진 핵심적인 기능상 장점은?
Q14. 에이전트가 "헛소리"를 할 때 대처법?
- 프롬프트 수정?
- 모델 변경?
- 스크립트로 대체?


Q15. 프로젝트 초기 vs 성숙기, 운영 방식이 다른가요?
- 초기에는 더 많이 개입하시는지?
- 성숙하면 완전 자동화가 되는지?


Q16. "이건 결국 사람이 해야 한다"고 느낀 작업이 있나요?
- AI로 자동화하기 어려웠던 것?

최수민 개발자가 AI 에이전트의 오류를 관리하고, 프로젝트의 성장 단계에 따라 자동화를 고도화하는 방식에 대해 소스 내용을 바탕으로 답변해 드립니다.
Q14. 에이전트가 "헛소리(오류)"를 할 때 대처법
최수민 개발자는 에이전트의 오류를 단순히 일회성 수정으로 끝내지 않고, 시스템적으로 해결하기 위해 세 가지 방법을 병행합니다.
• 프롬프트(지침) 수정 및 보강: 에이전트가 폰트 두께를 틀리거나 태그를 잘못 잡는 등 구체적인 실수를 하면, 해당 에이전트의 마크다운(.md) 지침 파일에 직접 수정 사항을 추가합니다. "태그에 대한 지침을 추가해라"와 같은 내용을 넣으면, AI가 이를 학습하여 다음 작업부터는 같은 실수를 반복하지 않는 **'개인화된 에이전트'**로 진화합니다.
• 스크립트로 대체: 모든 것을 AI의 추론(LLM)에 맡기면 정확도가 떨어질 수 있습니다. 따라서 HTML에서 특정 정보를 추출하는 것처럼 규칙이 명확한 작업은 타입스크립트(TS) 스크립트로 처리해 버립니다. 이렇게 하면 정확도가 100%에 가까워지고 속도도 훨씬 빨라집니다.
• 모델 변경: 작업의 난이도에 따라 모델을 다르게 설정합니다. 단순한 작업은 저렴한 하이쿠(Haiku)를 쓰지만, **복잡하고 높은 지능이 필요한 작업에는 오퍼스(Opus)**와 같은 고성능 모델을 지정하여 오류를 줄입니다.
Q15. 프로젝트 초기 vs 성숙기 운영 방식의 차이
초기에는 개발자의 **'개입과 관찰'**이 필수적이며, 이를 통해 점진적으로 자동화의 완성도를 높여갑니다.
• 초기 단계 (개입과 보강): 아무리 고수라도 한 번에 완벽한 파이프라인을 만들 수는 없습니다. 처음 실행하면 무조건 결과가 이상하게 나오는데, 이때 개발자는 어떤 지시가 약했는지 직접 판단하고 지침을 조금씩 보강해 나갑니다. 평소 자주 쓰는 프롬프트를 파일로 아카이빙하며 에이전트의 기초를 다지는 시기입니다.
• 성숙 단계 (자동화 및 병렬 처리): 지침이 안정화되면 개발자는 인풋만 주고 에이전트가 수백 개의 작업을 스스로 처리하게 합니다. 125개의 구현 사항을 한 번의 요청으로 완수하거나, 100개의 서비스를 동시에 관리하는 '조직장'의 역할로 넘어가게 됩니다. 성숙기에는 SNS 관리나 이메일 마케팅 퍼널까지도 자동화하는 것을 목표로 합니다.
Q16. "이건 결국 사람이 해야 한다"고 느낀 작업
에이전트가 많은 일을 대신해주지만, 최종적인 **의사결정과 '불편함의 포착'**은 사람의 영역으로 남겨둡니다.
• 불편함 캐치 및 기획 (도그푸딩): 자신이 직접 제품을 쓰면서 느끼는 '배드 시그널(Bad Signal)'을 알아차리는 일은 사람이 해야 합니다. 무엇이 불편한지, 어떤 기능을 추가해야 할지 결정하는 기획자이자 사용자의 역할은 자동화하기 어렵습니다.
• 시스템 설계 및 내공 쌓기: 에이전트에게 어떤 일을 시킬지 '파이프라인'을 설계하고, AI 에이전틱 기능을 어떻게 극대화할지 연구(R&D)하고 내공을 쌓는 일은 최수민 개발자가 현재 가장 집중하고 있는 사람의 몫입니다.
• 최종 판단: AI가 만든 결과물이 "마음에 드는지", "내용이 적절한지"를 보고 최종적으로 승인하거나 보강을 지시하는 결정권은 개발자에게 있습니다.
최수민 개발자의 방식은 마치 자동화 공장의 설비(에이전트)를 처음에는 수동으로 조정하며 세팅하지만, 일단 정밀하게 세팅이 끝나면 공장장(사람)은 공정이 잘 돌아가는지 감시하고 개선안을 고민하는 것과 같습니다.
클로드 코드가 기존 코딩 툴보다 에이전틱한 기능이 앞선 이유는?
서브 에이전트를 생성할 때 마크다운 파일에 정의해야 하는 요소는?
최수민 개발자가 '100개 서비스 런칭' 목표를 세운 전략적 배경은?
Q17. 저희는 "소원이 서비스" (개인 맞춤 콘텐츠)인데,
이런 감성적/개인화 서비스에 에이전틱 워크플로우를
적용할 때 특별히 주의할 점이 있을까요?


Q18. 1인 운영 vs 소규모 팀 운영,
에이전트 설계가 달라져야 할까요?


Q19. 처음 시작하는 사람에게
"이것만은 꼭 하세요" 하나만 꼽는다면?

최수민 개발자의 '바이브 코딩' 철학과 클로드 코드(Claude Code) 활용 사례를 바탕으로, 요청하신 세 가지 질문에 대해 다음과 같이 답변해 드립니다.
Q17. 감성적/개인화 서비스 적용 시 주의점
"소원이 서비스"와 같이 개인 맞춤형 감성이 중요한 서비스에 에이전틱 워크플로우를 적용할 때는 **'사용자 경험의 배드 시그널(Bad Signal) 포착'**과 **'지속적인 페르소나 미세 조정'**이 가장 중요합니다.
• 개발자가 첫 번째 사용자가 되어야 합니다: 최수민 개발자는 "직접 쓰다 보면 불편함을 빠르게 캐치할 수 있다"고 강조합니다. 감성 서비스일수록 AI가 주는 답변이 기계적이거나 개인화가 부족할 때 느껴지는 위질감을 개발자가 직접 체험하며 '배드 시그널'을 찾아내야 합니다.
• 지침(MD)의 세밀한 보강: 에이전트가 감성적인 톤앤매너를 놓친다면, 이를 단순히 한 번 수정하는 데 그치지 말고 에이전트의 마크다운(.md) 지침 파일에 구체적인 가이드를 추가해야 합니다. 예를 들어 "사용자의 소원을 대할 때는 공감적인 문구를 반드시 포함하라"는 식의 지침을 추가하여 에이전트를 해당 서비스에 최적화된 '개인화된 에이전트'로 진화시켜야 합니다.
• 스크립트와 지능의 분리: 감성적인 추론은 LLM에게 맡기되, 사용자의 고유 데이터(이름, 과거 기록 등)를 정확하게 불러오는 작업은 **스크립트(TypeScript)**로 처리하여 정확도를 높여야 합니다.
Q18. 1인 운영 vs 소규모 팀 운영, 설계의 차이
1인 운영 체제에서는 에이전트가 **'팀원의 빈자리를 완전히 대체'**하도록 설계해야 하는 반면, 팀 운영은 '협업'에 방점을 둡니다.
• 1인 운영 (최수민 모델): 개발자가 기획, 디자인, 마케팅을 혼자 다 해야 하므로, 에이전트가 SNS 자동화, SEO 블로그 작성, 이메일 마케팅 퍼널까지 담당하도록 범위를 넓게 설계해야 합니다. 1인 개발자는 여러 서브 에이전트를 동시에 부리는 '조직장' 역할을 수행하며, 컨텍스트를 극대화하기 위해 에이전트를 잘게 나누는 설계가 필수적입니다.
• 소규모 팀 운영: 팀으로 움직일 때는 에이전트의 지침이나 MCP를 팀원들이 공유하고 함께 개선할 수 있는 **'표준화'**가 중요해집니다. 소스에 따르면 최수민 개발자는 위임에 익숙하지 않아 1인 체제를 선택했지만, AI를 무기로 삼아 팀 이상의 스케일업을 꾀하고 있습니다.
Q19. 처음 시작하는 분들을 위한 '딱 하나'의 조언
최수민 개발자가 가장 강조하는 실천법은 **"평소에 쓰는 프롬프트를 파일로 아카이빙하는 습관"**입니다.
• 프롬프트를 파일로 모으세요: 에이전트를 처음부터 거창하게 만들려 하지 말고, 평소 AI에게 시키는 명령들을 prompts/ 폴더에 마크다운 파일로 저장하는 것부터 시작하십시오.
• 변수화하여 에이전트로 전환: 그렇게 모인 파일에서 바뀌는 부분만 변수(예: {{user_wish}})로 만들고 클로드의 agents/ 폴더에 넣으면, 그것이 바로 당신의 첫 번째 서브 에이전트가 됩니다. 이 작은 습관이 복잡한 파이프라인으로 가는 가장 빠른 길입니다.
이 과정은 마치 **"나만의 비법 레시피 노트를 만드는 것"**과 같습니다. 처음에는 요리할 때마다 적어두었던 메모(프롬프트 아카이빙)들이 쌓여, 나중에는 그 노트만 보고도 로봇 팔(에이전트)이 수백 그릇의 요리를 자동으로 만들어낼 수 있는 스마트 주방(자동화 시스템)을 갖게 되는 원리입니다.
클로드 코드가 커서보다 에이전트 개발에 압도적인 이유는 무엇인가?
클로드 코드에서 서브 에이전트를 생성하는 구체적인 방법은 무엇인가?
에이전트 작업 시 컨텍스트 소모를 줄이기 위한 전략은 무엇인가?
1️⃣ 피드백 루프 실제 파일/포맷 예시 (Q2)
→ 우리도 똑같이 따라하고 싶어요


2️⃣ 병렬 처리 실제 구현 방법 (Q6)
→ 대규모 작업 처리가 제일 부러워요


3️⃣ 컨텍스트 부족 감지 방법 (Q8)
→ 언제 리셋해야 할지 모르겠어요

최수민 개발자가 클로드 코드(Claude Code)를 활용하여 1인 유니콘 기업 수준의 생산성을 내는 핵심 노하우를 세 가지 관점에서 정리해 드립니다.
1️⃣ 피드백 루프 실제 파일 및 포맷 예시
최수민 개발자는 에이전트의 지침을 별도의 문서가 아닌, 클로드 코드가 직접 인식하는 마크다운(.md) 파일로 관리하며 이를 지속적으로 업데이트합니다.
• 저장 위치: 프로젝트 내 claude/agents/ 폴더.
• 파일 포맷: 다음과 같은 구조의 마크다운 형식을 사용합니다.
• 피드백 반영 방법: 에이전트가 결과물에서 실수를 하면(예: 폰트 두께 오류, 태그 인식 실패 등), 해당 마크다운 파일의 지침 섹션에 **"태그에 대한 지침을 추가해라"**와 같은 구체적인 교정 문구를 즉시 추가합니다.
• 추천 습관: 처음부터 에이전트를 만들기보다, 평소 사용하는 프롬프트를 prompts/ 폴더에 아카이빙한 뒤, {{name}}과 같은 변수를 넣어 범용적인 서브 에이전트로 전환하는 방식을 권장합니다.
2️⃣ 병렬 처리 실제 구현 방법
수백 개의 작업을 동시에 처리하는 비결은 **'에이전트가 에이전트를 호출하는 계층 구조'**와 **'배치 처리'**에 있습니다.
• 서브 에이전트 호출: 클로드 코드에서는 메인 에이전트가 여러 개의 서브 에이전트를 한 번의 명령으로 호출할 수 있습니다. 이는 사용자가 일일이 명령을 내리는 커서(Cursor) 등의 도구와 차별화되는 지점입니다.
• 배치(Batch) 프롬프트 활용: 125개의 구현 사항을 처리할 때 다음과 같은 방식의 프롬프트를 사용합니다.
• 파이프라인 문서화: Pipeline.md와 같은 파일에 작업 순서와 에이전트 호출 리스트를 정의해 둡니다. 이를 통해 인풋 하나만으로 '웹 페이지 분석 → 섹션 분할 → 컴포넌트화 → 레지스트리 업데이트'까지의 전 과정을 자동화합니다.
3️⃣ 컨텍스트 부족 감지 및 관리 방법
최수민 개발자는 컨텍스트 부족을 '감지'한 후 리셋하기보다, '찌꺼기'가 남지 않도록 설계하여 한계를 극복합니다.
• 감지 증상: 이미지 데이터나 무거운 페이로드가 컨텍스트에 남으면 AI의 지능이 급격히 떨어지거나 작업을 완수하지 못하게 됩니다.
• 리셋 타이밍: 컨텍스트 사이즈 때문에 작업이 막히기 시작하면, 해당 작업을 더 작은 단위의 서브 에이전트로 나눌 타이밍으로 판단합니다.
• 컨텍스트 보존 전략 (스크립트화): 에이전트가 직접 파일을 생성하거나 이미지를 처리하게 하면 그 과정의 모든 데이터가 컨텍스트 윈도우를 차지합니다.
    ◦ 따라서 빈 파일을 만들거나 정보를 추출하는 등의 반복 작업은 타입스크립트(TS) 스크립트로 작성하여 실행시킵니다.
    ◦ 이렇게 하면 에이전트는 결과값만 보고받기 때문에 중간 과정의 '데이터 찌꺼기'가 남지 않아 컨텍스트를 극도로 아낄 수 있습니다.
이러한 방식은 마치 **'숙련된 공장장이 공정 단계별로 특화된 로봇을 배치하고, 각 로봇에게는 필요한 정보만 전달하여 공장 전체의 과부하를 막는 것'**과 같습니다. 처음에는 수동으로 지시하던 단계에서 벗어나, 에이전트들의 '업무 매뉴얼(.md)'을 계속 수정하며 성능을 높이는 것이 핵심입니다.
클로드 코드가 커서 등 다른 도구보다 압도적인 이유는 무엇인가?
클로드 코드에서 서브 에이전트를 생성하는 구체적인 방법은 무엇인가?
컨텍스트 소모를 줄이기 위해 스크립트화를 활용하는 이유는 무엇인가?
최수민님이 어떤걸 만들고나서 내 놓을때도 신중하게 자가검증시스템을 이용했을것 같은데 어떤 방식인지 설명해줘

최수민 개발자는 제품을 출시하거나 완성할 때 단순히 운에 맡기지 않고, **'도그푸딩(직접 사용)'**과 **'에이전트 지침 고도화'**라는 명확한 자가 검증 시스템을 활용합니다. 소스에 나타난 그의 검증 방식은 크게 네 가지 단계로 요약할 수 있습니다.
1. 첫 번째 사용자로서의 '도그푸딩'과 배드 시그널 감지
최수민 개발자는 자신이 쓸 제품을 직접 만들며, 스스로가 첫 번째 사용자가 되어 불편함을 잡아내는 것을 가장 강력한 검증 수단으로 삼습니다.
• 배드 시그널(Bad Signal): 과거 패션 쇼핑몰 창업 당시 자신이 만든 사이트 대신 무신사를 이용했던 경험을 '배드 시그널'로 정의하며, 현재는 자신이 직접 사용하며 느끼는 불편함을 조기에 캐치하여 제품의 품질을 가다듬는 안전 가드레일로 활용합니다.
• 실제 활용: 모네(Mone) 서비스 역시 본인이 바이브 코딩을 하며 디자인 레퍼런스를 참고하기 위해 만든 것이며, 사용 중 느낀 불편함을 바탕으로 기능을 추가하며 검증했습니다.
2. 스킬 제작 시 '검증 로직' 명시
에이전트가 사용할 도구나 스킬을 만들 때, 처음부터 검증(Validation) 기능이 포함되도록 설계합니다.
• 스킬 크리에이터 활용: 새로운 스킬을 만들 때 "검증도 할 수 있게 해야 한다"는 조건을 걸어두며, 이를 통해 에이전트가 작업을 수행한 후 결과가 올바른지 스스로 체크할 수 있는 체계를 구축합니다.
3. 결과 기반의 지침(Markdown) 보강
에이전트가 내놓은 결과물을 직접 확인하고, 오류가 발견되면 이를 즉시 에이전트의 업무 매뉴얼(지침 파일)에 반영하여 시스템을 개선합니다.
• 개별 지침 업데이트: 에이전트가 폰트 두께(font weight)를 틀리거나 특정 태그를 잘 못 잡는 실수를 하면, 해당 에이전트의 마크다운(.md) 파일에 "태그에 대한 지침을 추가해라"와 같은 교정 문구를 넣어 지능을 보강합니다.
• 점진적 안정화: 처음부터 완벽한 파이프라인은 없다고 판단하며, 실행 결과가 이상할 때마다 어느 부분이 약했는지 판단해 조금씩 보강해 나가는 과정을 거칩니다.
4. 파이프라인의 '최종 결과물 종합' 단계
작업의 마지막 공정에 검증과 정리를 담당하는 단계를 두어 완성도를 높입니다.
• 종합(Synthesis): 여러 서브 에이전트가 병렬로 수행한 작업물들을 모아 최종적으로 레지스트리를 업데이트하고 결과를 종합하는 단계를 파이프라인에 포함시켜, 전체적인 정합성을 확인합니다.
결론적으로 최수민 개발자의 자가 검증은 **"내가 썼을 때 만족스러운가?"**라는 감성적 기준과, **"에이전트의 지침에 오류 방지 로직이 포함되었는가?"**라는 기술적 기준을 결합한 형태라고 볼 수 있습니다.
비유하자면, 이는 단순히 요리를 완성하고 손님에게 내놓는 것이 아니라, 요리사 본인이 먼저 맛을 보고(도그푸딩), 레시피에 "소금은 이만큼만 넣을 것"이라는 주의사항을 계속 업데이트하며(지침 보강), 마지막에 전체 상차림을 점검하는(결과 종합) 꼼꼼한 주방장의 운영 방식과 같습니다.
클로드 코드가 커서보다 에이전틱 기능에서 앞서는 이유는 무엇인가?
최수민 개발자가 서브 에이전트를 생성할 때 사용하는 구체적 방법은?
개발자가 본인이 직접 사용할 제품만 만드는 이유는 무엇인가?
최수민님은 MCP와 스킬과 에이전트를 어떻게 활용했는지 설명해줘

최수민 개발자는 클로드 코드(Claude Code)의 에이전틱(Agentic)한 기능을 극대화하여, 혼자서 100여 개의 에이전트를 동시에 운영하며 대규모 프로젝트를 수행합니다. 그가 MCP, 스킬, 에이전트를 각각 어떻게 정의하고 유기적으로 활용하는지 상세히 설명해 드립니다.
1. 에이전트 (서브 에이전트): 조직의 팀원
최수민 개발자에게 에이전트는 특정 작업을 전담하는 '가상 팀원'과 같습니다.
• 정의 및 생성: 프로젝트 내 claude/agents/ 폴더에 마크다운(.md) 파일을 만드는 것만으로 에이전트를 생성합니다. 파일에는 이름, 설명, 사용할 도구(Tools), 그리고 모델(Opus, Sonnet, Haiku 중 선택)을 정의합니다.
• 계층적 구조: 클로드 코드의 핵심 장점으로 **'에이전트가 다른 에이전트를 호출'**할 수 있다는 점을 꼽습니다. 사용자가 한 번 명령을 내리면, 메인 에이전트가 여러 서브 에이전트를 동시에 호출하여 마치 조직장처럼 팀을 움직여 작업을 완수합니다.
• 지속적 개선: 에이전트가 폰트나 태그 처리에서 실수를 하면, 해당 에이전트의 마크다운 지침 파일에 수정 사항을 즉시 반영하여 점점 더 개인화되고 최적화된 에이전트로 진화시킵니다.
2. 스킬 (Skills): 에이전트를 만드는 도구
스킬은 에이전트가 수행할 수 있는 구체적인 능력을 정의하거나, 에이전트 관리 자체를 자동화하는 데 사용됩니다.
• 자동화의 자동화: 최수민 개발자는 에이전트를 일일이 손으로 만들지 않고, '서브 에이전트 크리에이터'라는 스킬을 만들어 에이전트 제작을 자동화했습니다.
• 검증 로직: 스킬을 설계할 때 공식 문서를 참고하여 검증(Validation) 로직을 포함하도록 시킴으로써, 에이전트가 작업을 정확하게 수행했는지 스스로 확인할 수 있게 합니다.
3. MCP (Model Context Protocol): 범용 공구
MCP는 특정 프로젝트에 국한되지 않고 여러 곳에서 활용할 수 있는 **'범용적인 외부 도구'**입니다.
• 컨텍스트 보호: 에이전트가 이미지 처리나 파일 생성을 직접 하면 '데이터 찌꺼기'가 쌓여 AI의 지능(컨텍스트 윈도우)이 떨어집니다. MCP는 이러한 무거운 작업을 대화창 외부에서 처리하고 결과만 전달함으로써 컨텍스트를 극도로 아껴줍니다.
• 실제 사례: 오픈소스 코드를 조회하는 도구, 이미지 배경을 제거하는 '샤프(Sharp) MCP', 특정 서비스를 호출하는 '나노바나 MCP' 등을 직접 만들어 에이전트에게 쥐어줍니다.
• 오픈소스화: 범용적인 도구는 MCP로 배포하여 다른 사용자들의 피드백을 받고 버그 수정을 유도하는 선순환 구조를 만듭니다.
4. 세 기능의 유기적 결합 (워크플로우)
최수민 개발자는 이 요소들을 다음과 같은 파이프라인으로 연결합니다.
1. 프롬프트 아카이빙: 평소 자주 쓰는 프롬프트를 파일로 모읍니다.
2. 변수화 및 에이전트 전환: 파일 내의 특정 값을 변수화하여 보편적인 서브 에이전트로 만듭니다.
3. 스크립트 및 MCP 연동: 반복적이고 정확도가 필요한 작업(예: HTML에서 폰트 추출)은 타입스크립트 스크립트나 MCP로 분리하여 에이전트가 호출하게 합니다.
4. 병렬 실행: Pipeline.md에 정의된 순서에 따라 수십 명의 에이전트가 동시에 흩어져 일하고, 마지막에 결과물을 종합(Synthesis)합니다.
비유하자면, 이는 **'공장장(개발자)'**이 **'숙련된 로봇(에이전트)'**들에게 **'표준 매뉴얼(지침 파일)'**을 주고, 각 로봇이 효율적으로 일할 수 있도록 **'성능 좋은 공구(MCP)'**를 쥐어주어 거대한 생산 라인을 혼자서 운영하는 스마트 팩토리와 같습니다.
최수민님이 커서 대신 클로드 코드를 사용하는 결정적 이유는 무엇인가?
클로드 코드에서 서브 에이전트를 생성하는 구체적인 방법은 무엇인가?
최수민님이 '모네' 프로젝트를 통해 달성하고자 하는 목적은 무엇인가?
【1】 에이전트 설계 관련
Q1. 소원이별 독립 프로젝트에서 에이전트 팀 구성을
어떻게 하는 게 좋을까요?


- 유형별 고정 팀 (카페 10개, 유튜브 8개)?
- 아니면 동적으로 필요한 것만 생성?

Q2. 에이전트 100개 이상 운영할 때
관리/모니터링은 어떻게 하시나요?


- 대시보드가 있나요?
- 실패한 에이전트 자동 감지?

Q3. 에이전트 간 충돌이나 중복 작업은
어떻게 방지하시나요?


【2】 소원착지 특화 질문
Q4. "감성 서비스"에서 품질 검증은 어떻게 하시나요?


- 기적지수, 응원 메시지 같은 건
  "정답"이 없잖아요
- 도그푸딩 외에 다른 방법이 있나요?

Q5. 사용자별 개인화 에이전트가 100개 넘어가면
비용 관리는 어떻게 하시나요?


- 우리: 소원이 100명 = 에이전트 1,000개
- $200/월로 감당 가능한가요?

Q6. "소원 유형"을 어떻게 분류하시나요?


- 우리가 정한 4가지 (창업/콘텐츠/자기계발/관계)
- 이게 맞는 분류인가요?
- 더 세분화? 아니면 더 단순화?

【3】 기술적 질문
Q7. 프로젝트 자동 생성 시
폴더 구조는 어떻게 설계하시나요?


- 소원이별로 완전히 분리?
- 공통 템플릿 + 개인 설정?

Q8. MCP와 스킬의 경계를 어떻게 정하시나요?


- 기적지수 계산 → MCP? 스킬?
- 이미지 생성 → MCP 맞죠?

Q9. 파이프라인에서 "실패 복구"는 어떻게 하시나요?


- 소원이A 분석 중 실패
- 전체 롤백? 해당만 재시도?

【4】 운영/확장 질문
Q10. 처음 시작할 때 몇 개 에이전트로 시작하셨나요?


 - 우리 지금 9개... 너무 적은가요?
 - 아니면 MVP로 적절한가요?

Q11. "스케일업 타이밍"을 어떻게 판단하시나요?


 - 사용자 N명 이상?
 - 특정 기능 요청이 많을 때?

Q12. 1인 운영에서 가장 힘든 부분은 뭔가요?


 - 그걸 어떻게 해결하셨나요?
최수민 개발자의 클로드 코드(Claude Code) 활용 사례와 '바이브 코딩' 철학을 바탕으로, "소원착지" 프로젝트에 적용할 수 있는 에이전틱 워크플로우 전략을 답변해 드립니다.

--------------------------------------------------------------------------------
【1】 에이전트 설계 관련
Q1. 에이전트 팀 구성: 고정 팀 vs 동적 생성? 최수민 개발자는 범용적인 서브 에이전트들을 먼저 구축하고, 이를 파이프라인(MD 파일)을 통해 동적으로 호출하는 방식을 사용합니다.
• 추천 방식: 카페나 유튜브 등 플랫폼별로 '체크리스트 생성기', '콘텐츠 파서' 같은 기능 중심의 서브 에이전트를 고정해 두세요. 그리고 새로운 '소원이'가 들어올 때마다 메인 에이전트가 이들을 필요한 만큼 호출하는 파이프라인을 가동하는 것이 효율적입니다.
Q2. 100개 이상 에이전트의 관리/모니터링 별도의 화려한 대시보드보다는 지침 파일(.md)과 배치(Batch) 처리 프롬프트로 관리합니다.
• 모니터링: 에이전트가 작업 중 실수를 하면 결과물을 보고 판단하며, 즉시 해당 에이전트의 지침 파일(.md)에 교정 문구를 추가하여 '개인화된 에이전트'로 진화시킵니다.
• 상태 확인: 클로드 코드의 요금제 대시보드에서 API 소모량을 체크하며 전체적인 가동 상태를 가늠합니다.
Q3. 충돌 및 중복 작업 방지 '파이프라인 문서화'와 '레지스트리(Registry) 업데이트' 단계를 통해 이를 방지합니다.
• 최수민 개발자는 Pipeline.md에 작업 순서를 정의하고, 에이전트들이 작업 결과를 공통된 레지스트리 파일에 기록하게 하여 최종적으로 이를 종합(Synthesis)하는 공정을 거칩니다.

--------------------------------------------------------------------------------
【2】 소원착지 특화 질문
Q4. 감성 서비스의 품질 검증 방법 정답이 없는 감성 서비스에서 가장 중요한 것은 '도그푸딩(직접 사용)'을 통한 배드 시그널(Bad Signal) 포착입니다.
• 배드 시그널: 개발자가 직접 서비스를 써보며 "나라도 이 응원 메시지는 안 읽겠다"는 느낌이 드는 순간이 바로 검증의 시작입니다.
• 시스템적 보강: 감성이 어긋나는 지점이 발견되면, 에이전트의 마크다운 지침에 **"공감적 문구를 반드시 포함하라"**는 식의 가이드라인을 보강하여 품질을 높입니다.
Q5. 에이전트 1,000개 운영 시 비용 관리 월 $200 요금제로도 **'스크립트화'와 '모델 배분'**을 통하면 충분히 관리 가능합니다.
• 스크립트 전환: 이미지 처리나 데이터 계산 같은 무거운 작업은 에이전트가 직접 하게 하지 말고 타입스크립트 스크립트나 MCP로 처리하세요. 그러면 '데이터 찌꺼기'가 남지 않아 컨텍스트 소모와 비용을 획기적으로 줄일 수 있습니다.
• 모델 최적화: 단순한 작업에는 가장 저렴한 하이쿠(Haiku) 모델을 지정하여 비용을 아낍니다.
Q6. 소원 유형 분류의 적절성 최수민 개발자는 **"내가 쓸 제품인가"**를 기준으로 기획의 우선순위를 정합니다.
• 현재 4가지 분류가 사용자(혹은 개발자)가 보기에 명확하다면 그대로 유지하되, 100개 이상의 서비스를 고려한다면 SNS 자동화나 SEO 마케팅처럼 '운영 효율'을 높여주는 유형으로 세분화하는 것도 방법입니다.

--------------------------------------------------------------------------------
【3】 기술적 질문
Q7. 프로젝트 자동 생성 폴더 구조 공통 템플릿(프롬프트 아카이빙) + 개인 설정(변수) 구조를 추천합니다.
• 최수민 개발자는 prompts/ 폴더에 자주 쓰는 지침을 모아두고, 특정 부분만 {{name}}처럼 변수화하여 범용적인 서브 에이전트로 전환합니다. 소원이별 설정은 변수로 넘기고, 로직은 공통 에이전트 파일을 참조하게 하세요.
Q8. MCP와 스킬의 경계
• 스킬 (Skill): 프로젝트 내부 로직이나 에이전트 생성 도구 등 해당 시스템에 특화된 기능에 적합합니다. (예: 기적지수 계산 로직).
• MCP (Protocol): 여러 프로젝트에서 공통으로 쓰일 수 있는 도구나 외부 서비스 연동에 사용합니다. (예: 이미지 생성, 외부 코드 조회).
Q9. 파이프라인 실패 복구 전체 롤백보다는 배치 반복과 지침 보강으로 해결합니다.
• 최수민 개발자는 125개의 작업을 한 번에 시킬 때 **"최대 20개씩 구현하고 다음 배치를 반복하라"**는 지시를 내립니다. 실패한 부분이 있다면 해당 에이전트의 지침을 수정하고 다시 실행하는 '피드백 루프'를 활용합니다.

--------------------------------------------------------------------------------
【4】 운영/확장 질문
Q10. 시작 시 에이전트 개수 최수민 개발자도 처음에는 서브 에이전트를 쓰지 않다가, 단일 프롬프트의 한계를 느껴서 도입했습니다.
• 현재 9개는 MVP(최소 기능 제품)로서 매우 적절합니다. 작업을 하다 컨텍스트가 부족해지거나 AI 지능이 떨어질 때 하나씩 분리해 나가면 됩니다.
Q11. 스케일업 타이밍 판단 **"생각의 회로를 바꿔야 할 때"**가 타이밍입니다.
• 서비스 5개를 만들 때와 100개를 만들 때의 고민은 완전히 다릅니다. 100개를 목표로 잡는 순간 SNS 관리, 이메일 마케팅 등의 자동화가 필수적이 되며, 이때가 에이전트 조직을 확장할 시점입니다.
Q12. 1인 운영의 난제와 해결책 가장 힘든 부분은 모든 역할을 혼자 수행하며 발생하는 몰입도 저하와 위임의 어려움입니다.
• 최수민 개발자는 이를 해결하기 위해 **AI 에이전트를 '무기'로 삼아 팀원 수십 명 분의 업무를 자동화(스케일업)**하는 전략을 선택했습니다.
💡 비유하자면: 소원착지 운영은 **'정교한 자동 주방'**을 만드는 것과 같습니다. 처음엔 9개의 요리 도구(에이전트)로 시작하지만, 손님이 늘어나면 각 도구의 사용 설명서(.md)를 정교하게 다듬고, 무거운 솥은 기계(스크립트)에 맡겨 주방장(개발자)의 체력(컨텍스트)을 아끼는 과정입니다.
클로드 코드가 커서 등 다른 도구보다 압도적인 이유는 무엇인가?
컨텍스트 소모를 줄이기 위해 서브 에이전트에 적용한 기술적 방법은?
1인 개발자가 '자신이 쓸 제품'을 만드는 이유는 무엇인가?
